{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"modify","text":"Version Status Documentation Tools Compatibility Stats"},{"location":"#what-is-modify","title":"What is modify?","text":"<p><code>modify</code> gives you tools to modify and transfrom Python objects using a universal, intuitive syntax.</p>"},{"location":"#why-use-modify","title":"Why use modify?","text":"<p>Rather than remembering every command and its parameters for modifying and transforming Python objects, you can simply import <code>modify</code> and use the same syntax and arguments for any supported modification or transforming command. <code>modify</code> is:</p> <ul> <li>Lightweight: it has no dependencies and a miniscule memory footprint.</li> <li>Intuitive: every function name uses obvious, readable terms (e.g.,   functions that add something uses the prefix \"add\", functions that remove   something use the prefix \"drop\", etc.).</li> <li>Flexible: you can either call a general or specific function.   For example, as discussed below, to add a prefix to every <code>str</code> item in a   list-like object, you can call <code>add_prefix_to_list</code> or <code>add_prefix</code>. In the   latter case, if the function detects the passed item is a <code>MutableSequence</code>,   calls <code>add_prefix_to_list</code> automatically.</li> </ul>"},{"location":"#getting-started","title":"Getting started","text":""},{"location":"#installation","title":"Installation","text":"<p>To install <code>modify</code>, use <code>pip</code>:</p> <pre><code>pip install modify\n</code></pre>"},{"location":"#usage","title":"Usage","text":"<p>In this readme and the package documentation, these are the definitions of commonly used terms:</p> <ul> <li>\"converter\": function that changes an item's type.</li> <li>\"modifier\": function that changes an item, but not its type (although, in a couple cases, a <code>modifier</code> will produce more than one of the original type).</li> <li>\"transformer\": either a \"converter\" or \"modifier\".</li> </ul>"},{"location":"#general-vs-specific-tools","title":"General vs Specific Tools","text":"<p><code>modify</code> uses Python's <code>singledispatch</code> system. That means you can call the general function for transformation and it will call the appropriate function based on the type of the first positional argument passed.<sup>1</sup></p> <p>Alternatively, every function called by <code>modify</code>'s dispatchers is also callable directly using a straightforward syntax. For example, to add a string prefix to every item in a <code>list</code> (or <code>list</code>-like object), you could call:</p> <pre><code>add_prefix(your_list, prefix, divider) # divider is optional\n</code></pre> <p>or:</p> <pre><code>add_prefix_to_list(your_list, prefix, divider) # divider is optional\n</code></pre> <p>The dispatchers are just a convenience for shorter calls and require you to remember less verbiage. However, the specific functions are also included for effectuate greater reliability and clarity in your code.</p>"},{"location":"#dispatchers","title":"Dispatchers","text":"<p>The table below outlines the functionality of the general transformers (dispatchers), what types they support, and whether there is a recursive option for applying the function to nested objects as well.</p> name effect supported types (including generic equivalents) recursive parameter <code>add_prefix</code> Adds <code>prefix</code> to <code>item</code> with optional <code>divider</code> <code>dict</code>, <code>list</code>, <code>set</code>, <code>str</code>, <code>tuple</code> \u2705 <code>add_suffix</code> Adds <code>suffix</code> to <code>item</code> with optional <code>divider</code> <code>dict</code>, <code>list</code>, <code>set</code>, <code>str</code>, <code>tuple</code> \u2705 <code>capitalify</code> Changes text to capital case <code>dict</code>, <code>list</code>, <code>set</code>, <code>str</code>, <code>tuple</code> \u2705 <code>cleave</code> Divides 1 object into 2 objects <code>dict</code>, <code>list</code>, <code>str</code>, <code>tuple</code> <code>drop_dunders</code> Drops items that begin with 2 underscores <code>dict</code>, <code>list</code>, <code>object</code>, <code>str</code>, <code>tuple</code> <code>drop_duplicates</code> Drops duplicate items <code>list</code>, <code>str</code>, <code>tuple</code> <code>drop_dunders</code> Drops items that begin with at least 1 underscore <code>dict</code>, <code>list</code>, <code>object</code>, <code>str</code>, <code>tuple</code> <code>drop_prefix</code> Drops <code>suffix</code> from <code>item</code> with optional <code>divider</code> <code>dict</code>, <code>list</code>, <code>set</code>, <code>str</code>, <code>tuple</code> \u2705 <code>drop_substring</code> Drops <code>substring</code> from <code>item</code> <code>dict</code>, <code>list</code>, <code>set</code>, <code>str</code>, <code>tuple</code> \u2705 <code>drop_suffix</code> Adds <code>suffix</code> from <code>item</code> with optional <code>divider</code> <code>dict</code>, <code>list</code>, <code>set</code>, <code>str</code>, <code>tuple</code> \u2705 <code>separate</code> Divides 1 object into n objects <code>dict</code>, <code>list</code>, <code>str</code>, <code>tuple</code> <code>snakify</code> Changes text to snake case <code>dict</code>, <code>list</code>, <code>set</code>, <code>str</code>, <code>tuple</code> \u2705 <p>You should feel confident using the general transformers as long as you pass a supported type or its generic equivalent (e.g. <code>MutableMapping</code> for <code>dict</code>). The only limitations would be if you have created a custom class that appears as multiple types or masks its underlying type. There are also a few specific functions (e.g. <code>add_slots</code> for <code>dataclasses</code>) for which there is no general transformer because only one datatype is possible. Nonetheless, <code>modify</code> supports direct access to all of the specific transformers used (rather than making them anonymous functions as most uses of dispatching do).</p>"},{"location":"#specific-transformers","title":"Specific Transformers","text":"<p>Each specific tool in <code>modify</code> follows a common syntax, outlined below:</p> <code>dict</code> <code>list</code> <code>object</code> <code>set</code> <code>str</code> <code>tuple</code> <code>values</code> <code>add_prefix_to_</code> \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 <code>add_slots_</code> \u2705 <code>add_suffix_to_</code> \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 <code>capitalify_</code> \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 <code>cleave_</code> \u2705 \u2705 \u2705 \u2705 \u2705 <code>drop_dunders_from_</code> \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 <code>drop_duplicates_from_</code> \u2705 \u2705 \u2705 <code>drop_prefix_from_</code> \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 <code>drop_privates_from_</code> \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 <code>drop_substring_from_</code> \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 <code>drop_suffix_from_</code> \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 <code>separate_</code> \u2705 \u2705 \u2705 \u2705 \u2705 <code>snakify_</code> \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 <p>The <code>dict</code> suffix to function names refers to the keys of a <code>dict</code>-like object. <code>values</code> refers to the values of a <code>dict</code>-like object. If the related dispatcher identifies a passed item as a MutableMapping, the <code>dict</code> (and not <code>values</code>) function is called. Thus, changing values in a <code>dict</code>-like objects is the one instance when you must call the specific transformer instead of the general one.</p> <p><code>object</code>, as a suffix is inclusive of any class, instance, or module other than the other listed types. This is because many of the same underlying commands (such as <code>getattr</code> work in the same manner across those data types).</p>"},{"location":"#contributing","title":"Contributing","text":"<p>Contributors are always welcome. Feel free to grab an issue to work on or make a suggested improvement. If you wish to contribute, please read the Contribution Guide and Code of Conduct.</p>"},{"location":"#similar-projects","title":"Similar Projects","text":"<ul> <li><code>itertools</code>:</li> <li><code>more-itertools</code>:</li> </ul>"},{"location":"#acknowledgments","title":"Acknowledgments","text":"<p>I would like to thank the University of Kansas School of Law for tolerating and supporting this law professor's coding efforts, an endeavor which is well outside the typical scholarly activities in the discipline.</p>"},{"location":"#license","title":"License","text":"<p>Use of this repository is authorized under the Apache Software License 2.0.</p> <ol> <li> <p>Python's <code>singlddispatch</code> only supports dispatching based on the first positional argument. Because <code>modify</code> was designed to be lightweight, it uses this limited system rather than relying on a more sophisticated dispatching package.\u00a0\u21a9</p> </li> </ol>"},{"location":"changelog/","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file.</p>"},{"location":"changelog/#010","title":"0.1.0","text":"<pre><code>Initial Commit\n</code></pre>"},{"location":"code_of_conduct/","title":"Contributor Covenant Code of Conduct","text":""},{"location":"code_of_conduct/#our-pledge","title":"Our Pledge","text":"<p>In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to make participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation.</p>"},{"location":"code_of_conduct/#our-standards","title":"Our Standards","text":"<p>Examples of behavior that contributes to creating a positive environment include:</p> <ul> <li>Using welcoming and inclusive language</li> <li>Being respectful of differing viewpoints and experiences</li> <li>Gracefully accepting constructive criticism</li> <li>Focusing on what is best for the community</li> <li>Showing empathy towards other community members</li> </ul> <p>Examples of unacceptable behavior by participants include:</p> <ul> <li>The use of sexualized language or imagery and unwelcome sexual attention or   advances</li> <li>Trolling, insulting/derogatory comments, and personal or political attacks</li> <li>Public or private harassment</li> <li>Publishing others' private information, such as a physical or electronic   address, without explicit permission</li> <li>Other conduct which could reasonably be considered inappropriate in a   professional setting</li> </ul>"},{"location":"code_of_conduct/#our-responsibilities","title":"Our Responsibilities","text":"<p>Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior.</p> <p>Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful.</p>"},{"location":"code_of_conduct/#scope","title":"Scope","text":"<p>This Code of Conduct applies within all project spaces, and it also applies when an individual is representing the project or its community in public spaces. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers.</p>"},{"location":"code_of_conduct/#enforcement","title":"Enforcement","text":"<p>Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting any of the following people:</p> <ul> <li>Corey Rayburn Yung (coreyrayburnyung@gmail.com)</li> </ul> <p>All complaints will be reviewed and investigated and will result in a response that is deemed necessary and appropriate to the circumstances. The project team is obligated to maintain confidentiality with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately.</p> <p>Project maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project's leadership.</p>"},{"location":"code_of_conduct/#attribution","title":"Attribution","text":"<p>This Code of Conduct is adapted from the Contributor Covenant, version 1.4, available at https://www.contributor-covenant.org/version/1/4/code-of-conduct.html</p> <p>For answers to common questions about this code of conduct, see https://www.contributor-covenant.org/faq</p>"},{"location":"contributing/","title":"Contributing","text":"<p>Contributions are welcome and greatly appreciated! Every little bit helps, and credit will always be given. Environment Setup</p>"},{"location":"contributing/#development","title":"Development","text":"<p>Follow this basic process:</p> <ol> <li>Fork and clone the repositor.</li> <li>Create a new branch: <code>git checkout -b feature-or-bugfix-name</code>.</li> <li>Edit the code.</li> <li>If you added functionality or features, update the documentation accordingly.</li> </ol> <p>If you are unsure about how to fix or ignore a warning, just let the continuous integration fail, and we will help you during review.</p> <p>Don't bother updating the changelog, we will take care of this.</p>"},{"location":"contributing/#pull-requests-guidelines","title":"Pull requests guidelines","text":"<p>Link to any related issue in the Pull Request message.</p> <p>During the review, we recommend using fixups:</p> <pre><code># SHA is the SHA of the commit you want to fix\ngit commit --fixup=SHA\n</code></pre> <p>Once all the changes are approved, you can squash your commits:</p> <pre><code>git rebase -i --autosquash main\n</code></pre> <p>And force-push:</p> <pre><code>git push -f\n</code></pre> <p>If this seems all too complicated, you can push or force-push each new commit, and we will squash them ourselves if needed, before merging.</p>"},{"location":"contributing/#style-guidelines","title":"Style Guidelines","text":"<p>This package follows the Google Python Style Guide with two notable exceptions:</p> <ol> <li>It always adds spaces around \"=\". This not only violates the Google guide, it violates PEP8, the foundational Python style guide from which all other resources are derived. I defy this strong, long-standign norm because I find it more readable. My brain and eyes have trouble seeing two separate objects when an equal sign is in the middle. I imagine that I am not alone in this accessibility issue. Further, as PEP8 itself notes, required spaces around equal signs are becoming increasing common with type annotations becoming part of best practices (and, as a result, signatures to classes, functions, and methods regularly include spaces around the equal signs). I realize that this will seem alien to many coders, but it is far easier on my eyes.</li> <li>I use some so-called \"power features\", primarily dunder methods, to make my interfaces easier to access and use. This is disfavored in the Google Python Style Guide because such code is often more difficult for others to read. To address that concern, I try to document and comment as to what the code is doing whenever I used any of the \"power features\" of Python.</li> </ol>"},{"location":"credits/","title":"Credits","text":"<p><p>These projects were used to build modify. Thank you!</p> <p><code>python</code> | <code>pdm</code></p> </p>"},{"location":"credits/#exec-1--runtime-dependencies","title":"Runtime dependencies","text":"Project Summary Version (accepted) Version (last resolved) License"},{"location":"credits/#exec-1--development-dependencies","title":"Development dependencies","text":"Project Summary Version (accepted) Version (last resolved) License <code>babel</code> Internationalization utilities <code>~=2.10</code> <code>2.14.0</code> BSD-3-Clause <code>certifi</code> Python package for providing Mozilla's CA Bundle. <code>&gt;=2017.4.17</code> <code>2024.2.2</code> MPL-2.0 <code>cfgv</code> Validate configuration and produce human readable error messages. <code>&gt;=2.0.0</code> <code>3.4.0</code> MIT <code>charset-normalizer</code> The Real First Universal Charset Detector. Open, modern and actively maintained alternative to Chardet. <code>&lt;4,&gt;=2</code> <code>3.3.2</code> MIT <code>click</code> Composable command line interface toolkit <code>&gt;=7.0</code> <code>8.1.7</code> BSD-3-Clause <code>colorama</code> Cross-platform colored terminal text. <code>&gt;=0.4; platform_system == \"Windows\"</code> <code>0.4.6</code> BSD License <code>coverage</code> Code coverage measurement for Python <code>&gt;= 7.2.7</code> <code>7.4.4</code> Apache-2.0 <code>csscompressor</code> A python port of YUI CSS Compressor <code>&gt;=0.9.5</code> <code>0.9.5</code> BSD <code>distlib</code> Distribution utilities <code>&lt;1,&gt;=0.3.7</code> <code>0.3.8</code> PSF-2.0 <code>exceptiongroup</code> Backport of PEP 654 (exception groups) <code>&gt;=1.0.0rc8; python_version &lt; \"3.11\"</code> <code>1.2.0</code> ? <code>execnet</code> execnet: rapid multi-Python deployment <code>&gt;=1.1</code> <code>2.1.0</code> MIT License <code>filelock</code> A platform independent file lock. <code>&lt;4,&gt;=3.12.2</code> <code>3.13.3</code> The Unlicense (Unlicense) <code>ghp-import</code> Copy your docs directly to the gh-pages branch. <code>&gt;=1.0</code> <code>2.1.0</code> Apache Software License <code>gitdb</code> Git Object Database <code>&lt;5,&gt;=4.0.1</code> <code>4.0.11</code> BSD License <code>gitpython</code> GitPython is a Python library used to interact with Git repositories <code>3.1.43</code> BSD-3-Clause <code>griffe</code> Signatures for entire Python programs. Extract the structure, the frame, the skeleton of your project, to generate API documentation or find breaking changes in your API. <code>&gt;=0.37</code> <code>0.42.1</code> ISC <code>htmlmin2</code> An HTML Minifier <code>&gt;=0.1.13</code> <code>0.1.13</code> BSD <code>identify</code> File identification library for Python <code>&gt;=1.0.0</code> <code>2.5.35</code> MIT <code>idna</code> Internationalized Domain Names in Applications (IDNA) <code>&lt;4,&gt;=2.5</code> <code>3.6</code> BSD License <code>iniconfig</code> brain-dead simple config-ini parsing <code>2.0.0</code> MIT License <code>jinja2</code> A very fast and expressive template engine. <code>&gt;=2.11.1</code> <code>3.1.3</code> BSD-3-Clause <code>jsmin</code> JavaScript minifier. <code>&gt;=3.0.1</code> <code>3.0.1</code> MIT License <code>markdown</code> Python implementation of John Gruber's Markdown. <code>&gt;=3.3.3</code> <code>3.6</code> BSD License <code>markdown-callouts</code> Markdown extension: a classier syntax for admonitions <code>&gt;= 0.3</code> <code>0.4.0</code> MIT License <code>markdown-exec</code> Utilities to execute code blocks in Markdown files. <code>&gt;= 1.6.0</code> <code>1.8.0</code> ISC <code>markupsafe</code> Safely add untrusted strings to HTML/XML markup. <code>&gt;=2.0.1</code> <code>2.1.5</code> BSD-3-Clause <code>mergedeep</code> A deep merge function for \ud83d\udc0d. <code>&gt;=1.3.4</code> <code>1.3.4</code> MIT License <code>mkdocs</code> Project documentation with Markdown. <code>&gt;= 1.5.2</code> <code>1.5.3</code> BSD License <code>mkdocs-coverage</code> MkDocs plugin to integrate your coverage HTML report into your site. <code>&gt;= 1.0.0</code> <code>1.0.0</code> ISC <code>mkdocs-gen-files</code> MkDocs plugin to programmatically generate documentation pages during the build <code>&gt;= 0.5.0</code> <code>0.5.0</code> MIT License <code>mkdocs-git-committers-plugin-2</code> An MkDocs plugin to create a list of contributors on the page. The git-committers plugin will seed the template context with a list of GitHub or GitLab committers and other useful GIT info such as last modified date <code>&gt;= 1.1.2</code> <code>2.3.0</code> MIT <code>mkdocs-literate-nav</code> MkDocs plugin to specify the navigation in Markdown instead of YAML <code>&gt;= 0.6.0</code> <code>0.6.1</code> MIT License <code>mkdocs-material</code> Documentation that simply works <code>&gt;= 9.1.2</code> <code>9.5.17</code> MIT License <code>mkdocs-material-extensions</code> Extension pack for Python Markdown and MkDocs Material. <code>~=1.3</code> <code>1.3.1</code> MIT License <code>mkdocs-minify-plugin</code> An MkDocs plugin to minify HTML, JS or CSS files prior to being written to disk <code>&gt;= 0.7.1</code> <code>0.8.0</code> MIT <code>mkdocstrings</code> Automatic documentation from sources, for MkDocs. <code>[python] &gt;= 0.22.0</code> <code>0.24.3</code> ISC <code>mkdocstrings-python</code> A Python handler for mkdocstrings. <code>&gt;=0.5.2</code> <code>1.9.2</code> ISC <code>nodeenv</code> Node.js virtual environment builder <code>&gt;=0.11.1</code> <code>1.8.0</code> BSD <code>packaging</code> Core utilities for Python packages <code>&gt;=20.5</code> <code>24.0</code> BSD License <code>paginate</code> Divides large result sets into pages for easier browsing <code>~=0.5</code> <code>0.5.6</code> MIT <code>pathspec</code> Utility library for gitignore style pattern matching of file paths. <code>&gt;=0.11.1</code> <code>0.12.1</code> Mozilla Public License 2.0 (MPL 2.0) <code>platformdirs</code> A small Python package for determining appropriate platform-specific dirs, e.g. a \"user data dir\". <code>&gt;=2.2.0</code> <code>4.2.0</code> MIT License <code>pluggy</code> plugin and hook calling mechanisms for python <code>&lt;2.0,&gt;=1.4</code> <code>1.4.0</code> MIT <code>pre-commit</code> A framework for managing and maintaining multi-language pre-commit hooks. <code>&gt;= 3.3.3</code> <code>3.7.0</code> MIT <code>pygments</code> Pygments is a syntax highlighting package written in Python. <code>~=2.16</code> <code>2.17.2</code> BSD-2-Clause <code>pymdown-extensions</code> Extension pack for Python Markdown. <code>&gt;=9</code> <code>10.7.1</code> MIT License <code>pytest</code> pytest: simple powerful testing with Python <code>&gt;= 7.4.0</code> <code>8.1.1</code> MIT <code>pytest-cov</code> Pytest plugin for measuring coverage. <code>&gt;= 4.1.0</code> <code>5.0.0</code> MIT <code>pytest-randomly</code> Pytest plugin to randomly order tests and control random.seed. <code>&gt;= 3.13.0</code> <code>3.15.0</code> MIT <code>pytest-xdist</code> pytest xdist plugin for distributed testing, most importantly across multiple CPUs <code>&gt;= 3.3.1</code> <code>3.5.0</code> MIT <code>python-dateutil</code> Extensions to the standard Python datetime module <code>&gt;=2.8.1</code> <code>2.9.0.post0</code> Dual License <code>pyyaml</code> YAML parser and emitter for Python <code>&gt;=5.1</code> <code>6.0.1</code> MIT <code>pyyaml-env-tag</code> A custom YAML tag for referencing environment variables in YAML files. <code>&gt;=0.1</code> <code>0.1</code> MIT License <code>regex</code> Alternative regular expression module, to replace re. <code>&gt;=2022.4</code> <code>2023.12.25</code> Apache Software License <code>requests</code> Python HTTP for Humans. <code>2.31.0</code> Apache 2.0 <code>ruff</code> An extremely fast Python linter and code formatter, written in Rust. <code>&gt;= 0.0.286</code> <code>0.3.5</code> MIT <code>setuptools</code> Easily download, build, install, upgrade, and uninstall Python packages <code>69.2.0</code> MIT License <code>six</code> Python 2 and 3 compatibility utilities <code>&gt;=1.5</code> <code>1.16.0</code> MIT <code>smmap</code> A pure Python implementation of a sliding window memory map manager <code>&lt;6,&gt;=3.0.1</code> <code>5.0.1</code> BSD <code>toml</code> Python Library for Tom's Obvious, Minimal Language <code>&gt;= 0.10.2</code> <code>0.10.2</code> MIT <code>tomli</code> A lil' TOML parser <code>; python_full_version &lt;= \"3.11.0a6\"</code> <code>2.0.1</code> ? <code>urllib3</code> HTTP library with thread-safe connection pooling, file post, and more. <code>&lt;3,&gt;=1.21.1</code> <code>2.2.1</code> MIT License <code>virtualenv</code> Virtual Python Environment builder <code>&gt;=20.10.0</code> <code>20.25.1</code> MIT License <code>watchdog</code> Filesystem events monitoring <code>&gt;=2.0</code> <code>4.0.0</code> Apache-2.0"},{"location":"license/","title":"License","text":"<p>Apache Software License 2.0</p> <p>Copyright \u00a9 2024, Corey Rayburn Yung</p> <p>Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at</p> <p>http://www.apache.org/licenses/LICENSE-2.0</p> <p>Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.</p>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li> modify<ul> <li> alter<ul> <li> affix</li> <li> divide</li> <li> remove</li> <li> tinker</li> </ul> </li> <li> configuration</li> <li> convert<ul> <li> classes</li> <li> hashes</li> <li> mappings</li> <li> numbers</li> <li> parameters</li> <li> paths</li> <li> sequences</li> <li> strings</li> </ul> </li> <li> returns</li> </ul> </li> </ul>"},{"location":"reference/modify/","title":"Index","text":"<p>Python tools for transforming and modifying objects.</p>"},{"location":"reference/modify/configuration/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> configuration","text":"<p>Global settings for <code>modify</code>.</p> Contents <p>add_supported_type: adds a supported return type to <code>modify</code>. set_default_value: sets the global default for <code>kind</code> to <code>value</code>. set_raise_error: sets the global default setting of whether to raise errors. set_recursive: sets the global default setting for whether to apply a tool     recursively to nested items.</p> <p>To Do:</p>"},{"location":"reference/modify/configuration/#modify.configuration._MISSING_VALUE","title":"<code>_MISSING_VALUE()</code>  <code>dataclass</code>","text":"<p>Sentinel object for a missing data or parameter.</p> <p>This follows the same pattern as the <code>__MISSING_TYPE</code> class in the builtin dataclasses library. https://github.com/python/cpython/blob/3.10/Lib/dataclasses.py#L182-L186</p> <p>Because None is sometimes a valid argument or data option, this class provides an alternative that does not create the confusion that a default of None can sometimes lead to.</p>"},{"location":"reference/modify/configuration/#modify.configuration.add_supported_type","title":"<code>add_supported_type(kind, name, default)</code>","text":"<p>Adds a supported type.</p> <p>This function is only needed if you choose not to raise an error and you are using a dispatcher for a new type. In such situations, the <code>dict</code> of supported types is checked so that the appropriate default return value may be identified.</p> <p>Parameters:</p> Name Type Description Default <code>kind</code> <code>type</code> <p>the type to associate with the default value of <code>default</code>.</p> required <code>name</code> <code>str</code> <p><code>str</code> name of the type, which is used for naming the global default variable.</p> required <code>default</code> <code>Any</code> <p>default value to return when an error is not raised.</p> required <p>Raises:</p> Type Description <code>TypeError</code> <p>if <code>kind</code> is not a class or <code>name</code> is not a <code>str</code>.</p> Source code in <code>src/modify/configuration.py</code> <pre><code>def add_supported_type(kind: type, name: str, default: Any) -&gt; None:\n    \"\"\"Adds a supported type.\n\n    This function is only needed if you choose not to raise an error and you are\n    using a dispatcher for a new type. In such situations, the `dict` of\n    supported types is checked so that the appropriate default return value may\n    be identified.\n\n    Args:\n        kind: the type to associate with the default value of `default`.\n        name: `str` name of the type, which is used for naming the global\n            default variable.\n        default: default value to return when an error is not raised.\n\n    Raises:\n        TypeError: if `kind` is not a class or `name` is not a `str`.\n\n    \"\"\"\n    if isinstance(name, str):\n        if inspect.isclass(kind):\n            globals()['_SUPPORTED_TYPES'][kind] = name\n            default_variable_name = f'_DEFAULT_{name.upper()}'\n            globals[default_variable_name] = default\n        else:\n            raise TypeError('kind must be a class, not an instance')\n    else:\n        raise TypeError('name argument must be a str')\n</code></pre>"},{"location":"reference/modify/configuration/#modify.configuration.set_default_value","title":"<code>set_default_value(kind, value)</code>","text":"<p>Sets the global default for <code>kind</code> to <code>value</code>.</p> <p>Parameters:</p> Name Type Description Default <code>kind</code> <code>str</code> <p>short name of the type for which the default balue should be changed.</p> required <code>value</code> <code>Any</code> <p>valuet to assign as the default.</p> required Source code in <code>src/modify/configuration.py</code> <pre><code>def set_default_value(kind: str, value: Any) -&gt; None:\n    \"\"\"Sets the global default for `kind` to `value`.\n\n    Args:\n        kind: short name of the type for which the default balue should be\n            changed.\n        value: valuet to assign as the default.\n\n    \"\"\"\n    variable_name = f'_DEFAULT_{kind.upper()}'\n    try:\n        globals()[variable_name] = value\n    except KeyError as error:\n        message = f'{kind} is not a recognized type with a stored default value'\n        raise ValueError(message) from error\n</code></pre>"},{"location":"reference/modify/configuration/#modify.configuration.set_raise_error","title":"<code>set_raise_error(raise_error)</code>","text":"<p>Sets the global default setting of whether to raise errors.</p> <p>Parameters:</p> Name Type Description Default <code>raise_error</code> <code>bool</code> <p>whether to raise an exception (True) when a function cannot complete its task or to return a default value instead (False).</p> required <p>Raises:</p> Type Description <code>TypeError</code> <p>if <code>raise_error</code> is not a boolean.</p> Source code in <code>src/modify/configuration.py</code> <pre><code>def set_raise_error(raise_error: bool) -&gt; None:\n    \"\"\"Sets the global default setting of whether to raise errors.\n\n    Args:\n        raise_error: whether to raise an exception (True) when a function cannot\n            complete its task or to return a default value instead (False).\n\n    Raises:\n        TypeError: if `raise_error` is not a boolean.\n\n    \"\"\"\n    if isinstance(raise_error, bool):\n        globals()['_RAISE_ERROR'] = raise_error\n    else:\n        raise TypeError('raise_error argument must be a boolean')\n</code></pre>"},{"location":"reference/modify/configuration/#modify.configuration.set_recursive","title":"<code>set_recursive(recursive)</code>","text":"<p>Sets the global default setting for whether to apply a tool recursively.</p> <p>Parameters:</p> Name Type Description Default <code>recursive</code> <code>bool</code> <p>whether to apply the function to nested items (True).</p> required <p>Raises:</p> Type Description <code>TypeError</code> <p>if <code>recursive</code> is not a boolean.</p> Source code in <code>src/modify/configuration.py</code> <pre><code>def set_recursive(recursive: bool) -&gt; None:\n    \"\"\"Sets the global default setting for whether to apply a tool recursively.\n\n    Args:\n        recursive: whether to apply the function to nested items (True).\n\n    Raises:\n        TypeError: if `recursive` is not a boolean.\n\n    \"\"\"\n    if isinstance(recursive, bool):\n        globals()['_RECURSIVE'] = recursive\n    else:\n        raise TypeError('recursive argument must be a boolean')\n</code></pre>"},{"location":"reference/modify/returns/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> returns","text":"<p>Tools for error processing and returning values.</p> <p>Contents:</p> <p>To Do:</p>"},{"location":"reference/modify/returns/#modify.returns._infer_type","title":"<code>_infer_type(item)</code>","text":"<p>Infers type of <code>item</code> among supported types.</p> <p>This function is only needed when using a dispatcher and the raise error is False.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Any</code> <p>description</p> required <p>Returns:</p> Type Description <code>str</code> <p>description</p> Source code in <code>src/modify/returns.py</code> <pre><code>def _infer_type(item: Any) -&gt; str:\n    \"\"\"Infers type of `item` among supported types.\n\n    This function is only needed when using a dispatcher and the raise error is\n    False.\n\n    Args:\n        item: _description_\n\n    Returns:\n        _description_\n\n    \"\"\"\n    kind = None\n    if not inspect.isclass(item):\n        item = type(item)\n    for key, value in configuration._SUPPORTED_TYPES.items():\n        if issubclass(item, key):\n            kind = value\n            break\n    return kind\n</code></pre>"},{"location":"reference/modify/returns/#modify.returns._process_return","title":"<code>_process_return(raise_error, message, kind=None, item=None)</code>","text":"<p>Raises error with <code>message</code> or returns appropriate default value.</p> <p>Parameters:</p> Name Type Description Default <code>raise_error</code> <code>bool | MISSING</code> <p>whether to raise and error (True) or return a default value based on the argument of <code>kind</code>. If the argument is <code>configuration.MISSING</code>, then the global setting for raising errors will be used.</p> required <code>message</code> <code>str</code> <p>error message to use if an error is raised.</p> required <code>kind</code> <code>str | None</code> <p>str name of the type to be returned. Defaults to None.</p> <code>None</code> <code>item</code> <code>type | None</code> <p>item passed to tool. Defaults to None. <code>item</code> is only used if  <code>kind</code> is None.</p> <code>None</code> <p>Raises:</p> Type Description <code>TypeError</code> <p>if 1) <code>raise_error</code> is True or 2) <code>raise_error</code> is <code>configuration.MISSING</code> and the global setting for raising errors is True.</p> <code>ValueError</code> <p>if both <code>kind</code> and <code>item</code> are None.</p> Source code in <code>src/modify/returns.py</code> <pre><code>def _process_return(\n    raise_error: bool | configuration.MISSING,\n    message: str,\n    kind: str | None = None,\n    item: type | None = None ) -&gt; Any:\n    \"\"\"Raises error with `message` or returns appropriate default value.\n\n    Args:\n        raise_error: whether to raise and error (True) or return a default value\n            based on the argument of `kind`. If the argument is\n            `configuration.MISSING`, then the global setting for raising errors\n            will be used.\n        message: error message to use if an error is raised.\n        kind: str name of the type to be returned. Defaults to None.\n        item: item passed to tool. Defaults to None. `item` is only used if \n            `kind` is None.\n\n    Raises:\n        TypeError: if 1) `raise_error` is True or 2) `raise_error` is\n            `configuration.MISSING` and the global setting for raising errors is\n            True.\n        ValueError: if both `kind` and `item` are None.\n\n    \"\"\"\n    if raise_error is configuration.MISSING:\n        raise_error = configuration._RAISE_ERROR\n    if raise_error:\n        return TypeError(message)\n    if not kind:\n        if not item:\n            value_message = 'either the kind or item argument must not be None'\n            raise ValueError(value_message)\n        kind = _infer_type(item)\n        if kind is None:\n            raise TypeError(message)\n    return getattr(configuration, f'_DEFAULT_{kind.upper()}')\n</code></pre>"},{"location":"reference/modify/alter/","title":"Index","text":"<p>Python tools for modifying objects.</p>"},{"location":"reference/modify/alter/affix/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> affix","text":"<p>Tools that add things to objects.</p> Contents <p>General Tools (tools that call other functions based on type passed):     add_prefix: adds a <code>str</code> prefix to an item.     add_suffix: adds a <code>str</code> suffix to an item. Specific Tools:     add_prefix_to_dict: adds a <code>str</code> prefix to keys in a <code>dict</code>-like object.     add_prefix_to_list: adds a <code>str</code> prefix to a <code>list</code>-like object.     add_prefix_to_set: adds a <code>str</code> prefix to a <code>set</code>-like object.     add_prefix_to_str: adds a <code>str</code> prefix to a <code>str</code>.     add_prefix_tuple: adds a <code>str</code> prefix to a <code>tuple</code>-like object.     add_prefix_to_values: adds a <code>str</code> prefix to values in a <code>dict</code>-like         object.     add_slots: adds <code>__slots__</code> to a Python <code>dataclass</code>.     add_suffix_to_dict: adds a <code>str</code> suffix to keys in a <code>dict</code>-like object.     add_suffix_to_list: adds a <code>str</code> suffix to a <code>list</code>-like object.     add_suffix_to_set: adds a <code>str</code> suffix to a <code>set</code>-like object.     add_suffix_to_str: adds a <code>str</code> suffix to a <code>str</code>.     add_suffix_tuple: adds a <code>str</code> suffix to a <code>tuple</code>-like object.     add_suffix_to_values: adds a <code>str</code> suffix to values in a <code>dict</code>-like         object.</p> <p>To Do:</p>"},{"location":"reference/modify/alter/affix/#modify.alter.affix.add_prefix","title":"<code>add_prefix(item, prefix, divider='', *, recursive=configuration.MISSING, raise_error=configuration.MISSING)</code>","text":"<p>Adds <code>prefix</code> to <code>item</code> with <code>divider</code> in between.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Any</code> <p>item to be modified.</p> required <code>prefix</code> <code>str</code> <p>prefix to be added to <code>item</code>.</p> required <code>divider</code> <code>str</code> <p><code>str</code> to add between <code>item</code> and <code>prefix</code>. Defaults to '', which means no divider will be added. <code>divider</code> is included as a convenience for loops, but if you are just making isolated calls, you can just add the divider to <code>prefix</code>.</p> <code>''</code> <code>recursive</code> <code>bool | MISSING</code> <p>if <code>item</code> is nested, whether to apply the function to all nested objects as well (True) or merely the top level object (False). Defaults to <code>configuration.MISSING</code>, which means the glo raised (since there is no matching default value). Defaults tbal setting for <code>_RECURSIVE</code> will be used.</p> <code>MISSING</code> <code>raise_error</code> <code>bool | MISSING</code> <p>whether to raise an error (True) or to return a default value based on the type of <code>item</code> (False), when possible. If the dispatcher cannot find an appropriate type, an error is alwayso <code>configuration.MISSING</code>, which means the global setting for <code>_RAISE_ERROR</code> will be used.</p> <code>MISSING</code> <p>Returns:</p> Type Description <code>Any</code> <p>Modified item.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>if no registered function supports the type of <code>item</code>.</p> Source code in <code>src/modify/alter/affix.py</code> <pre><code>@functools.singledispatch\ndef add_prefix(\n    item: Any,\n    prefix: str,\n    divider: str  = '', *,\n    recursive: bool | configuration.MISSING = configuration.MISSING,\n    raise_error: bool | configuration.MISSING = configuration.MISSING) -&gt; Any:\n    \"\"\"Adds `prefix` to `item` with `divider` in between.\n\n    Args:\n        item: item to be modified.\n        prefix: prefix to be added to `item`.\n        divider: `str` to add between `item` and `prefix`. Defaults to '', which\n            means no divider will be added. `divider` is included as a\n            convenience for loops, but if you are just making isolated calls,\n            you can just add the divider to `prefix`.\n        recursive: if `item` is nested, whether to apply the function to all\n            nested objects as well (True) or merely the top level object\n            (False). Defaults to `configuration.MISSING`, which means the glo\n            raised (since there is no matching default value). Defaults tbal\n            setting for `_RECURSIVE` will be used.\n        raise_error: whether to raise an error (True) or to return a default\n            value based on the type of `item` (False), when possible. If the\n            dispatcher cannot find an appropriate type, an error is alwayso\n            `configuration.MISSING`, which means the global setting for\n            `_RAISE_ERROR` will be used.\n\n    Returns:\n        Modified item.\n\n    Raises:\n        TypeError: if no registered function supports the type of `item`.\n\n    \"\"\"\n    return returns._process_return(\n        raise_error = raise_error,\n        message = f'item is not a supported type for {__name__}',\n        item = item)\n</code></pre>"},{"location":"reference/modify/alter/affix/#modify.alter.affix.add_prefix_to_dict","title":"<code>add_prefix_to_dict(item, prefix, divider='', *, recursive=configuration.MISSING, raise_error=configuration.MISSING)</code>","text":"<p>Adds <code>prefix</code> to <code>item</code> with <code>divider</code> in between.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Any</code> <p>item to be modified.</p> required <code>prefix</code> <code>str</code> <p>prefix to be added to <code>item</code>.</p> required <code>divider</code> <code>str</code> <p><code>str</code> to add between <code>item</code> and <code>prefix</code>. Defaults to '', which means no divider will be added. <code>divider</code> is included as a convenience for loops, but if you are just making isolated calls, you can just add the divider to <code>prefix</code>.</p> <code>''</code> <code>recursive</code> <code>bool | MISSING</code> <p>if <code>item</code> is nested, whether to apply the function to all nested objects as well (True) or merely the top level object (False). Defaults to <code>configuration.MISSING</code>, which means the global setting for <code>_RECURSIVE</code> will be used.</p> <code>MISSING</code> <code>raise_error</code> <code>bool | MISSING</code> <p>whether to raise an error (True) or to return a default value based on the type of <code>item</code> (False), when possible. If the dispatcher cannot find an appropriate type, an error is always raised (since there is no matching default value). Defaults to <code>configuration.MISSING</code>, which means the global setting for <code>_RAISE_ERROR</code> will be used.</p> <code>MISSING</code> <p>Returns:</p> Type Description <code>Any</code> <p>Modified <code>dict</code>.</p> Source code in <code>src/modify/alter/affix.py</code> <pre><code>@add_prefix.register(Mapping)\ndef add_prefix_to_dict(\n    item: Any,\n    prefix: str,\n    divider: str  = '', *,\n    recursive: bool | configuration.MISSING = configuration.MISSING,\n    raise_error: bool | configuration.MISSING = configuration.MISSING) -&gt; Any:\n    \"\"\"Adds `prefix` to `item` with `divider` in between.\n\n    Args:\n        item: item to be modified.\n        prefix: prefix to be added to `item`.\n        divider: `str` to add between `item` and `prefix`. Defaults to '', which\n            means no divider will be added. `divider` is included as a\n            convenience for loops, but if you are just making isolated calls,\n            you can just add the divider to `prefix`.\n        recursive: if `item` is nested, whether to apply the function to all\n            nested objects as well (True) or merely the top level object\n            (False). Defaults to `configuration.MISSING`, which means the global\n            setting for `_RECURSIVE` will be used.\n        raise_error: whether to raise an error (True) or to return a default\n            value based on the type of `item` (False), when possible. If the\n            dispatcher cannot find an appropriate type, an error is always\n            raised (since there is no matching default value). Defaults to\n            `configuration.MISSING`, which means the global setting for\n            `_RAISE_ERROR` will be used.\n\n    Returns:\n        Modified `dict`.\n\n    \"\"\"\n    try:\n        base = type(item)\n        kwargs = {'prefix': prefix, 'divider': divider, 'recursive': recursive}\n        tool = add_prefix if recursive else add_prefix_to_str\n        return base({tool(k, **kwargs): v for k, v in item.items()})\n    except TypeError:\n        return returns._process_return(\n            raise_error = raise_error,\n            message = f'item is not a supported type for {__name__}',\n            kind = 'dict')\n</code></pre>"},{"location":"reference/modify/alter/affix/#modify.alter.affix.add_prefix_to_list","title":"<code>add_prefix_to_list(item, prefix, divider='', *, recursive=configuration.MISSING, raise_error=configuration.MISSING)</code>","text":"<p>Adds <code>prefix</code> to <code>item</code> with <code>divider</code> in between.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Any</code> <p>item to be modified.</p> required <code>prefix</code> <code>str</code> <p>prefix to be added to <code>item</code>.</p> required <code>divider</code> <code>str</code> <p><code>str</code> to add between <code>item</code> and <code>prefix</code>. Defaults to '', which means no divider will be added. <code>divider</code> is included as a convenience for loops, but if you are just making isolated calls, you can just add the divider to <code>prefix</code>.</p> <code>''</code> <code>recursive</code> <code>bool | MISSING</code> <p>if <code>item</code> is nested, whether to apply the function to all nested objects as well (True) or merely the top level object (False). Defaults to <code>configuration.MISSING</code>, which means the global setting for <code>_RECURSIVE</code> will be used.</p> <code>MISSING</code> <code>raise_error</code> <code>bool | MISSING</code> <p>whether to raise an error (True) or to return a default value based on the type of <code>item</code> (False), when possible. If the dispatcher cannot find an appropriate type, an error is always raised (since there is no matching default value). Defaults to <code>configuration.MISSING</code>, which means the global setting for <code>_RAISE_ERROR</code> will be used.</p> <code>MISSING</code> <p>Returns:</p> Type Description <code>Any</code> <p>Modified <code>list</code>.</p> Source code in <code>src/modify/alter/affix.py</code> <pre><code>@add_prefix.register(MutableSequence)\ndef add_prefix_to_list(\n    item: Any,\n    prefix: str,\n    divider: str  = '', *,\n    recursive: bool | configuration.MISSING = configuration.MISSING,\n    raise_error: bool | configuration.MISSING = configuration.MISSING) -&gt; Any:\n    \"\"\"Adds `prefix` to `item` with `divider` in between.\n\n    Args:\n        item: item to be modified.\n        prefix: prefix to be added to `item`.\n        divider: `str` to add between `item` and `prefix`. Defaults to '', which\n            means no divider will be added. `divider` is included as a\n            convenience for loops, but if you are just making isolated calls,\n            you can just add the divider to `prefix`.\n        recursive: if `item` is nested, whether to apply the function to all\n            nested objects as well (True) or merely the top level object\n            (False). Defaults to `configuration.MISSING`, which means the global\n            setting for `_RECURSIVE` will be used.\n        raise_error: whether to raise an error (True) or to return a default\n            value based on the type of `item` (False), when possible. If the\n            dispatcher cannot find an appropriate type, an error is always\n            raised (since there is no matching default value). Defaults to\n            `configuration.MISSING`, which means the global setting for\n            `_RAISE_ERROR` will be used.\n\n    Returns:\n        Modified `list`.\n\n    \"\"\"\n    try:\n        base = type(item)\n        kwargs = {'prefix': prefix, 'divider': divider, 'recursive': recursive}\n        tool = add_prefix if recursive else add_prefix_to_str\n        return base([tool(i, **kwargs) for i in item])\n    except TypeError:\n        return returns._process_return(\n            raise_error = raise_error,\n            message = f'item is not a supported type for {__name__}',\n            kind = 'list')\n</code></pre>"},{"location":"reference/modify/alter/affix/#modify.alter.affix.add_prefix_to_set","title":"<code>add_prefix_to_set(item, prefix, divider='', *, recursive=configuration.MISSING, raise_error=configuration.MISSING)</code>","text":"<p>Adds <code>prefix</code> to <code>item</code> with <code>divider</code> in between.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Any</code> <p>item to be modified.</p> required <code>prefix</code> <code>str</code> <p>prefix to be added to <code>item</code>.</p> required <code>divider</code> <code>str</code> <p><code>str</code> to add between <code>item</code> and <code>prefix</code>. Defaults to '', which means no divider will be added. <code>divider</code> is included as a convenience for loops, but if you are just making isolated calls, you can just add the divider to <code>prefix</code>.</p> <code>''</code> <code>recursive</code> <code>bool | MISSING</code> <p>if <code>item</code> is nested, whether to apply the function to all nested objects as well (True) or merely the top level object (False). Defaults to <code>configuration.MISSING</code>, which means the global setting for <code>_RECURSIVE</code> will be used.</p> <code>MISSING</code> <code>raise_error</code> <code>bool | MISSING</code> <p>whether to raise an error (True) or to return a default value based on the type of <code>item</code> (False), when possible. If the dispatcher cannot find an appropriate type, an error is always raised (since there is no matching default value). Defaults to <code>configuration.MISSING</code>, which means the global setting for <code>_RAISE_ERROR</code> will be used.</p> <code>MISSING</code> <p>Returns:</p> Type Description <code>Any</code> <p>Modified <code>set</code>.</p> Source code in <code>src/modify/alter/affix.py</code> <pre><code>@add_prefix.register(AbstractSet)\ndef add_prefix_to_set(\n    item: Any,\n    prefix: str,\n    divider: str  = '', *,\n    recursive: bool | configuration.MISSING = configuration.MISSING,\n    raise_error: bool | configuration.MISSING = configuration.MISSING) -&gt; Any:\n    \"\"\"Adds `prefix` to `item` with `divider` in between.\n\n    Args:\n        item: item to be modified.\n        prefix: prefix to be added to `item`.\n        divider: `str` to add between `item` and `prefix`. Defaults to '', which\n            means no divider will be added. `divider` is included as a\n            convenience for loops, but if you are just making isolated calls,\n            you can just add the divider to `prefix`.\n        recursive: if `item` is nested, whether to apply the function to all\n            nested objects as well (True) or merely the top level object\n            (False). Defaults to `configuration.MISSING`, which means the global\n            setting for `_RECURSIVE` will be used.\n        raise_error: whether to raise an error (True) or to return a default\n            value based on the type of `item` (False), when possible. If the\n            dispatcher cannot find an appropriate type, an error is always\n            raised (since there is no matching default value). Defaults to\n            `configuration.MISSING`, which means the global setting for\n            `_RAISE_ERROR` will be used.\n\n    Returns:\n        Modified `set`.\n\n    \"\"\"\n    try:\n        base = type(item)\n        kwargs = {'prefix': prefix, 'divider': divider, 'recursive': recursive}\n        tool = add_prefix if recursive else add_prefix_to_str\n        return base({tool(i, **kwargs) for i in item})\n    except TypeError:\n        return returns._process_return(\n            raise_error = raise_error,\n            message = f'item is not a supported type for {__name__}',\n            kind = 'set')\n</code></pre>"},{"location":"reference/modify/alter/affix/#modify.alter.affix.add_prefix_to_str","title":"<code>add_prefix_to_str(item, prefix, divider='', *, recursive=configuration.MISSING, raise_error=configuration.MISSING)</code>","text":"<p>Adds <code>prefix</code> to <code>item</code> with <code>divider</code> in between.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Any</code> <p>item to be modified.</p> required <code>prefix</code> <code>str</code> <p>prefix to be added to <code>item</code>.</p> required <code>divider</code> <code>str</code> <p><code>str</code> to add between <code>item</code> and <code>prefix</code>. Defaults to '', which means no divider will be added. <code>divider</code> is included as a convenience for loops, but if you are just making isolated calls, you can just add the divider to <code>prefix</code>.</p> <code>''</code> <code>recursive</code> <code>bool | MISSING</code> <p>ignored for <code>str</code> types because they cannot be nested.</p> <code>MISSING</code> <code>raise_error</code> <code>bool | MISSING</code> <p>whether to raise an error (True) or to return a default value based on the type of <code>item</code> (False), when possible. If the dispatcher cannot find an appropriate type, an error is always raised (since there is no matching default value). Defaults to <code>configuration.MISSING</code>, which means the global setting for <code>_RAISE_ERROR</code> will be used.</p> <code>MISSING</code> <p>Returns:</p> Type Description <code>Any</code> <p>Modified <code>str</code>.</p> Source code in <code>src/modify/alter/affix.py</code> <pre><code>@add_prefix.register(str)\ndef add_prefix_to_str(\n    item: Any,\n    prefix: str,\n    divider: str  = '', *,\n    recursive: bool | configuration.MISSING = configuration.MISSING,\n    raise_error: bool | configuration.MISSING = configuration.MISSING) -&gt; Any:\n    \"\"\"Adds `prefix` to `item` with `divider` in between.\n\n    Args:\n        item: item to be modified.\n        prefix: prefix to be added to `item`.\n        divider: `str` to add between `item` and `prefix`. Defaults to '', which\n            means no divider will be added. `divider` is included as a\n            convenience for loops, but if you are just making isolated calls,\n            you can just add the divider to `prefix`.\n        recursive: ignored for `str` types because they cannot be nested.\n        raise_error: whether to raise an error (True) or to return a default\n            value based on the type of `item` (False), when possible. If the\n            dispatcher cannot find an appropriate type, an error is always\n            raised (since there is no matching default value). Defaults to\n            `configuration.MISSING`, which means the global setting for\n            `_RAISE_ERROR` will be used.\n\n    Returns:\n        Modified `str`.\n\n    \"\"\"\n    try:\n        return divider.join([prefix, item])\n    except TypeError:\n        return returns._process_return(\n            raise_error = raise_error,\n            message = f'item is not a supported type for {__name__}',\n            kind = 'str')\n</code></pre>"},{"location":"reference/modify/alter/affix/#modify.alter.affix.add_prefix_to_tuple","title":"<code>add_prefix_to_tuple(item, prefix, divider='', *, recursive=configuration.MISSING, raise_error=configuration.MISSING)</code>","text":"<p>Adds <code>prefix</code> to <code>item</code> with <code>divider</code> in between.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Any</code> <p>item to be modified.</p> required <code>prefix</code> <code>str</code> <p>prefix to be added to <code>item</code>.</p> required <code>divider</code> <code>str</code> <p><code>str</code> to add between <code>item</code> and <code>prefix</code>. Defaults to '', which means no divider will be added. <code>divider</code> is included as a convenience for loops, but if you are just making isolated calls, you can just add the divider to <code>prefix</code>.</p> <code>''</code> <code>recursive</code> <code>bool | MISSING</code> <p>if <code>item</code> is nested, whether to apply the function to all nested objects as well (True) or merely the top level object (False). Defaults to <code>configuration.MISSING</code>, which means the global setting for <code>_RECURSIVE</code> will be used.</p> <code>MISSING</code> <code>raise_error</code> <code>bool | MISSING</code> <p>whether to raise an error (True) or to return a default value based on the type of <code>item</code> (False), when possible. If the dispatcher cannot find an appropriate type, an error is always raised (since there is no matching default value). Defaults to <code>configuration.MISSING</code>, which means the global setting for <code>_RAISE_ERROR</code> will be used.</p> <code>MISSING</code> <p>Returns:</p> Type Description <code>Any</code> <p>Modified <code>tuple</code>.</p> Source code in <code>src/modify/alter/affix.py</code> <pre><code>@add_prefix.register(tuple)\ndef add_prefix_to_tuple(\n    item: Any,\n    prefix: str,\n    divider: str  = '', *,\n    recursive: bool | configuration.MISSING = configuration.MISSING,\n    raise_error: bool | configuration.MISSING = configuration.MISSING) -&gt; Any:\n    \"\"\"Adds `prefix` to `item` with `divider` in between.\n\n    Args:\n        item: item to be modified.\n        prefix: prefix to be added to `item`.\n        divider: `str` to add between `item` and `prefix`. Defaults to '', which\n            means no divider will be added. `divider` is included as a\n            convenience for loops, but if you are just making isolated calls,\n            you can just add the divider to `prefix`.\n        recursive: if `item` is nested, whether to apply the function to all\n            nested objects as well (True) or merely the top level object\n            (False). Defaults to `configuration.MISSING`, which means the global\n            setting for `_RECURSIVE` will be used.\n        raise_error: whether to raise an error (True) or to return a default\n            value based on the type of `item` (False), when possible. If the\n            dispatcher cannot find an appropriate type, an error is always\n            raised (since there is no matching default value). Defaults to\n            `configuration.MISSING`, which means the global setting for\n            `_RAISE_ERROR` will be used.\n\n    Returns:\n        Modified `tuple`.\n\n    \"\"\"\n    try:\n        kwargs = {'prefix': prefix, 'divider': divider, 'recursive': recursive}\n        return tuple(add_prefix_to_list(item, **kwargs))\n    except TypeError:\n        return returns._process_return(\n            raise_error = raise_error,\n            message = f'item is not a supported type for {__name__}',\n            kind = 'tuple')\n</code></pre>"},{"location":"reference/modify/alter/affix/#modify.alter.affix.add_prefix_to_values","title":"<code>add_prefix_to_values(item, prefix, divider='', *, recursive=configuration.MISSING, raise_error=configuration.MISSING)</code>","text":"<p>Adds <code>prefix</code> to values in <code>item</code> with <code>divider</code> in between.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Any</code> <p>item to be modified.</p> required <code>prefix</code> <code>str</code> <p>prefix to be added to <code>item</code>.</p> required <code>divider</code> <code>str</code> <p><code>str</code> to add between <code>item</code> and <code>prefix</code>. Defaults to '', which means no divider will be added. <code>divider</code> is included as a convenience for loops, but if you are just making isolated calls, you can just add the divider to <code>prefix</code>.</p> <code>''</code> <code>recursive</code> <code>bool | MISSING</code> <p>if <code>item</code> is nested, whether to apply the function to all nested objects as well (True) or merely the top level object (False). Defaults to <code>configuration.MISSING</code>, which means the global setting for <code>_RECURSIVE</code> will be used.</p> <code>MISSING</code> <code>raise_error</code> <code>bool | MISSING</code> <p>whether to raise an error (True) or to return a default value based on the type of <code>item</code> (False), when possible. If the dispatcher cannot find an appropriate type, an error is always raised (since there is no matching default value). Defaults to <code>configuration.MISSING</code>, which means the global setting for <code>_RAISE_ERROR</code> will be used.</p> <code>MISSING</code> <p>Returns:</p> Type Description <code>Any</code> <p>Modified <code>dict</code>.</p> Source code in <code>src/modify/alter/affix.py</code> <pre><code>def add_prefix_to_values(\n    item: Any,\n    prefix: str,\n    divider: str  = '', *,\n    recursive: bool | configuration.MISSING = configuration.MISSING,\n    raise_error: bool | configuration.MISSING = configuration.MISSING) -&gt; Any:\n    \"\"\"Adds `prefix` to values in `item` with `divider` in between.\n\n    Args:\n        item: item to be modified.\n        prefix: prefix to be added to `item`.\n        divider: `str` to add between `item` and `prefix`. Defaults to '', which\n            means no divider will be added. `divider` is included as a\n            convenience for loops, but if you are just making isolated calls,\n            you can just add the divider to `prefix`.\n        recursive: if `item` is nested, whether to apply the function to all\n            nested objects as well (True) or merely the top level object\n            (False). Defaults to `configuration.MISSING`, which means the global\n            setting for `_RECURSIVE` will be used.\n        raise_error: whether to raise an error (True) or to return a default\n            value based on the type of `item` (False), when possible. If the\n            dispatcher cannot find an appropriate type, an error is always\n            raised (since there is no matching default value). Defaults to\n            `configuration.MISSING`, which means the global setting for\n            `_RAISE_ERROR` will be used.\n\n    Returns:\n        Modified `dict`.\n\n    \"\"\"\n    try:\n        base = type(item)\n        kwargs = {'prefix': prefix, 'divider': divider, 'recursive': recursive}\n        tool = add_prefix if recursive else add_prefix_to_str\n        return base({k: tool(v, **kwargs) for k, v in item.items()})\n    except TypeError:\n        return returns._process_return(\n            raise_error = raise_error,\n            message = f'item is not a supported type for {__name__}',\n            kind = 'dict')\n</code></pre>"},{"location":"reference/modify/alter/affix/#modify.alter.affix.add_slots","title":"<code>add_slots(item, raise_error=configuration.MISSING)</code>","text":"<p>Adds slots to dataclass with default values.</p> <p>This function is needed for those that want to use slots with Python dataclasses. There is no native support. So, slots have to be added after the fact (which cannot be done with ordinary Python classes).</p> <p>Derived from code here: https://gitquirks.com/ericvsmith/dataclasses/blob/master/dataclass_tools.py</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>type[dataclass]</code> <p>dataclass to add slots to.</p> required <code>raise_error</code> <code>bool | MISSING</code> <p>whether to raise an error (True) or to return <code>item' unmodified (False). Defaults to</code>configuration.MISSING<code>, which means  the global setting for</code>_RAISE_ERROR` will be used.</p> <code>MISSING</code> <p>Returns:</p> Type Description <code>type[dataclass]</code> <p>dataclass with <code>__slots__</code> added.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>if <code>__slots__</code> is already in <code>item</code> and the raise error settings is True.</p> Source code in <code>src/modify/alter/affix.py</code> <pre><code>def add_slots(\n    item: type[dataclasses.dataclass],\n    raise_error: bool | configuration.MISSING = configuration.MISSING) -&gt; (\n        type[dataclasses.dataclass]):\n    \"\"\"Adds slots to dataclass with default values.\n\n    This function is needed for those that want to use slots with Python\n    dataclasses. There is no native support. So, slots have to be added after\n    the fact (which cannot be done with ordinary Python classes).\n\n    Derived from code here:\n    https://gitquirks.com/ericvsmith/dataclasses/blob/master/dataclass_tools.py\n\n    Args:\n        item: dataclass to add slots to.\n        raise_error: whether to raise an error (True) or to return `item'\n            unmodified (False). Defaults to `configuration.MISSING`, which means \n            the global setting for `_RAISE_ERROR` will be used.\n\n    Returns:\n        dataclass with `__slots__` added.\n\n    Raises:\n        TypeError: if `__slots__` is already in `item` and the raise error\n            settings is True.\n\n    \"\"\"\n    if '__slots__' in item.__dict__:\n        if raise_error is configuration.MISSING:\n            raise_error = configuration._RAISE_ERROR\n        if raise_error:\n            raise TypeError(f'{item.__name__} already contains __slots__')\n        else:\n            return item\n    else:\n        item_dict = dict(item.__dict__)\n        field_names = tuple(f.name for f in dataclasses.fields(item))\n        item_dict['__slots__'] = field_names\n        for field_name in field_names:\n            item_dict.pop(field_name, None)\n        item_dict.pop('__dict__', None)\n        qualname = getattr(item, '__qualname__', None)\n        item = type(item)(item.__name__, item.__bases__, item_dict)\n        if qualname is not None:\n            item.__qualname__ = qualname\n    return item\n</code></pre>"},{"location":"reference/modify/alter/affix/#modify.alter.affix.add_suffix","title":"<code>add_suffix(item, suffix, divider='', *, recursive=configuration.MISSING, raise_error=configuration.MISSING)</code>","text":"<p>Adds <code>prefix</code> to <code>item</code> with <code>divider</code> in between.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Any</code> <p>item to be modified.</p> required <code>suffix</code> <code>str</code> <p>suffix to be added to <code>item</code>.</p> required <code>divider</code> <code>str</code> <p><code>str</code> to add between <code>item</code> and <code>suffix</code>. Defaults to '', which means no divider will be added. <code>divider</code> is included as a convenience for loops, but if you are just making isolated calls, you can just add the divider to <code>suffix</code>.</p> <code>''</code> <code>recursive</code> <code>bool | MISSING</code> <p>if <code>item</code> is nested, whether to apply the function to all nested objects as well (True) or merely the top level object (False). Defaults to <code>configuration.MISSING</code>, which means the global setting for <code>_RECURSIVE</code> will be used.</p> <code>MISSING</code> <code>raise_error</code> <code>bool | MISSING</code> <p>whether to raise an error (True) or to return a default value based on the type of <code>item</code> (False), when possible. If the dispatcher cannot find an appropriate type, an error is always raised (since there is no matching default value). Defaults to <code>configuration.MISSING</code>, which means the global setting for <code>_RAISE_ERROR</code> will be used.</p> <code>MISSING</code> <p>Returns:</p> Type Description <code>Any</code> <p>Modified item.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>if no registered function supports the type of 'item'.</p> Source code in <code>src/modify/alter/affix.py</code> <pre><code>@functools.singledispatch\ndef add_suffix(\n    item: Any,\n    suffix: str,\n    divider: str  = '', *,\n    recursive: bool | configuration.MISSING = configuration.MISSING,\n    raise_error: bool | configuration.MISSING = configuration.MISSING) -&gt; Any:\n    \"\"\"Adds `prefix` to `item` with `divider` in between.\n\n    Args:\n        item: item to be modified.\n        suffix: suffix to be added to `item`.\n        divider: `str` to add between `item` and `suffix`. Defaults to '', which\n            means no divider will be added. `divider` is included as a\n            convenience for loops, but if you are just making isolated calls,\n            you can just add the divider to `suffix`.\n        recursive: if `item` is nested, whether to apply the function to all\n            nested objects as well (True) or merely the top level object\n            (False). Defaults to `configuration.MISSING`, which means the global\n            setting for `_RECURSIVE` will be used.\n        raise_error: whether to raise an error (True) or to return a default\n            value based on the type of `item` (False), when possible. If the\n            dispatcher cannot find an appropriate type, an error is always\n            raised (since there is no matching default value). Defaults to\n            `configuration.MISSING`, which means the global setting for\n            `_RAISE_ERROR` will be used.\n\n    Returns:\n        Modified item.\n\n    Raises:\n        TypeError: if no registered function supports the type of 'item'.\n\n    \"\"\"\n    return returns._process_return(\n        raise_error = raise_error,\n        message = f'item is not a supported type for {__name__}',\n        item = item)\n</code></pre>"},{"location":"reference/modify/alter/affix/#modify.alter.affix.add_suffix_to_dict","title":"<code>add_suffix_to_dict(item, suffix, divider='', *, recursive=configuration.MISSING, raise_error=configuration.MISSING)</code>","text":"<p>Adds <code>prefix</code> to <code>item</code> with <code>divider</code> in between.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Any</code> <p>item to be modified.</p> required <code>suffix</code> <code>str</code> <p>suffix to be added to <code>item</code>.</p> required <code>divider</code> <code>str</code> <p><code>str</code> to add between <code>item</code> and <code>suffix</code>. Defaults to '', which means no divider will be added. <code>divider</code> is included as a convenience for loops, but if you are just making isolated calls, you can just add the divider to <code>suffix</code>.</p> <code>''</code> <code>recursive</code> <code>bool | MISSING</code> <p>if <code>item</code> is nested, whether to apply the function to all nested objects as well (True) or merely the top level object (False). Defaults to <code>configuration.MISSING</code>, which means the global setting for <code>_RECURSIVE</code> will be used.</p> <code>MISSING</code> <code>raise_error</code> <code>bool | MISSING</code> <p>whether to raise an error (True) or to return a default value based on the type of <code>item</code> (False), when possible. If the dispatcher cannot find an appropriate type, an error is always raised (since there is no matching default value). Defaults to <code>configuration.MISSING</code>, which means the global setting for <code>_RAISE_ERROR</code> will be used.</p> <code>MISSING</code> <p>Returns:</p> Type Description <code>Any</code> <p>Modified <code>dict</code>.</p> Source code in <code>src/modify/alter/affix.py</code> <pre><code>@add_suffix.register(Mapping)\ndef add_suffix_to_dict(\n    item: Any,\n    suffix: str,\n    divider: str  = '', *,\n    recursive: bool | configuration.MISSING = configuration.MISSING,\n    raise_error: bool | configuration.MISSING = configuration.MISSING) -&gt; Any:\n    \"\"\"Adds `prefix` to `item` with `divider` in between.\n\n    Args:\n        item: item to be modified.\n        suffix: suffix to be added to `item`.\n        divider: `str` to add between `item` and `suffix`. Defaults to '', which\n            means no divider will be added. `divider` is included as a\n            convenience for loops, but if you are just making isolated calls,\n            you can just add the divider to `suffix`.\n        recursive: if `item` is nested, whether to apply the function to all\n            nested objects as well (True) or merely the top level object\n            (False). Defaults to `configuration.MISSING`, which means the global\n            setting for `_RECURSIVE` will be used.\n        raise_error: whether to raise an error (True) or to return a default\n            value based on the type of `item` (False), when possible. If the\n            dispatcher cannot find an appropriate type, an error is always\n            raised (since there is no matching default value). Defaults to\n            `configuration.MISSING`, which means the global setting for\n            `_RAISE_ERROR` will be used.\n\n    Returns:\n        Modified `dict`.\n\n    \"\"\"\n    try:\n        base = type(item)\n        kwargs = {'suffix': suffix, 'divider': divider, 'recursive': recursive}\n        tool = add_suffix if recursive else add_suffix_to_str\n        return base({tool(k, **kwargs): v for k, v in item.items()})\n    except TypeError:\n        return returns._process_return(\n            raise_error = raise_error,\n            message = f'item is not a supported type for {__name__}',\n            kind = 'dict')\n</code></pre>"},{"location":"reference/modify/alter/affix/#modify.alter.affix.add_suffix_to_list","title":"<code>add_suffix_to_list(item, suffix, divider='', *, recursive=configuration.MISSING, raise_error=configuration.MISSING)</code>","text":"<p>Adds <code>prefix</code> to <code>item</code> with <code>divider</code> in between.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Any</code> <p>item to be modified.</p> required <code>suffix</code> <code>str</code> <p>suffix to be added to <code>item</code>.</p> required <code>divider</code> <code>str</code> <p><code>str</code> to add between <code>item</code> and <code>suffix</code>. Defaults to '', which means no divider will be added. <code>divider</code> is included as a convenience for loops, but if you are just making isolated calls, you can just add the divider to <code>suffix</code>.</p> <code>''</code> <code>recursive</code> <code>bool | MISSING</code> <p>if <code>item</code> is nested, whether to apply the function to all nested objects as well (True) or merely the top level object (False). Defaults to <code>configuration.MISSING</code>, which means the global setting for <code>_RECURSIVE</code> will be used.</p> <code>MISSING</code> <code>raise_error</code> <code>bool | MISSING</code> <p>whether to raise an error (True) or to return a default value based on the type of <code>item</code> (False), when possible. If the dispatcher cannot find an appropriate type, an error is always raised (since there is no matching default value). Defaults to <code>configuration.MISSING</code>, which means the global setting for <code>_RAISE_ERROR</code> will be used.</p> <code>MISSING</code> <p>Returns:</p> Type Description <code>Any</code> <p>Modified <code>list</code>.</p> Source code in <code>src/modify/alter/affix.py</code> <pre><code>@add_suffix.register(MutableSequence)\ndef add_suffix_to_list(\n    item: Any,\n    suffix: str,\n    divider: str  = '', *,\n    recursive: bool | configuration.MISSING = configuration.MISSING,\n    raise_error: bool | configuration.MISSING = configuration.MISSING) -&gt; Any:\n    \"\"\"Adds `prefix` to `item` with `divider` in between.\n\n    Args:\n        item: item to be modified.\n        suffix: suffix to be added to `item`.\n        divider: `str` to add between `item` and `suffix`. Defaults to '', which\n            means no divider will be added. `divider` is included as a\n            convenience for loops, but if you are just making isolated calls,\n            you can just add the divider to `suffix`.\n        recursive: if `item` is nested, whether to apply the function to all\n            nested objects as well (True) or merely the top level object\n            (False). Defaults to `configuration.MISSING`, which means the global\n            setting for `_RECURSIVE` will be used.\n        raise_error: whether to raise an error (True) or to return a default\n            value based on the type of `item` (False), when possible. If the\n            dispatcher cannot find an appropriate type, an error is always\n            raised (since there is no matching default value). Defaults to\n            `configuration.MISSING`, which means the global setting for\n            `_RAISE_ERROR` will be used.\n\n    Returns:\n        Modified `list`.\n\n    \"\"\"\n    try:\n        base = type(item)\n        kwargs = {'suffix': suffix, 'divider': divider, 'recursive': recursive}\n        tool = add_suffix if recursive else add_suffix_to_str\n        return base([tool(i, **kwargs) for i in item])\n    except TypeError:\n        return returns._process_return(\n            raise_error = raise_error,\n            message = f'item is not a supported type for {__name__}',\n            kind = 'list')\n</code></pre>"},{"location":"reference/modify/alter/affix/#modify.alter.affix.add_suffix_to_set","title":"<code>add_suffix_to_set(item, suffix, divider='', *, recursive=configuration.MISSING, raise_error=configuration.MISSING)</code>","text":"<p>Adds <code>prefix</code> to <code>item</code> with <code>divider</code> in between.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Any</code> <p>item to be modified.</p> required <code>suffix</code> <code>str</code> <p>suffix to be added to <code>item</code>.</p> required <code>divider</code> <code>str</code> <p><code>str</code> to add between <code>item</code> and <code>suffix</code>. Defaults to '', which means no divider will be added. <code>divider</code> is included as a convenience for loops, but if you are just making isolated calls, you can just add the divider to <code>suffix</code>.</p> <code>''</code> <code>recursive</code> <code>bool | MISSING</code> <p>if <code>item</code> is nested, whether to apply the function to all nested objects as well (True) or merely the top level object (False). Defaults to <code>configuration.MISSING</code>, which means the global setting for <code>_RECURSIVE</code> will be used.</p> <code>MISSING</code> <code>raise_error</code> <code>bool | MISSING</code> <p>whether to raise an error (True) or to return a default value based on the type of <code>item</code> (False), when possible. If the dispatcher cannot find an appropriate type, an error is always raised (since there is no matching default value). Defaults to <code>configuration.MISSING</code>, which means the global setting for <code>_RAISE_ERROR</code> will be used.</p> <code>MISSING</code> <p>Returns:</p> Type Description <code>Any</code> <p>Modified <code>set</code>.</p> Source code in <code>src/modify/alter/affix.py</code> <pre><code>@add_suffix.register(AbstractSet)\ndef add_suffix_to_set(\n    item: Any,\n    suffix: str,\n    divider: str  = '', *,\n    recursive: bool | configuration.MISSING = configuration.MISSING,\n    raise_error: bool | configuration.MISSING = configuration.MISSING) -&gt; Any:\n    \"\"\"Adds `prefix` to `item` with `divider` in between.\n\n    Args:\n        item: item to be modified.\n        suffix: suffix to be added to `item`.\n        divider: `str` to add between `item` and `suffix`. Defaults to '', which\n            means no divider will be added. `divider` is included as a\n            convenience for loops, but if you are just making isolated calls,\n            you can just add the divider to `suffix`.\n        recursive: if `item` is nested, whether to apply the function to all\n            nested objects as well (True) or merely the top level object\n            (False). Defaults to `configuration.MISSING`, which means the global\n            setting for `_RECURSIVE` will be used.\n        raise_error: whether to raise an error (True) or to return a default\n            value based on the type of `item` (False), when possible. If the\n            dispatcher cannot find an appropriate type, an error is always\n            raised (since there is no matching default value). Defaults to\n            `configuration.MISSING`, which means the global setting for\n            `_RAISE_ERROR` will be used.\n\n    Returns:\n        Modified `set`.\n\n    \"\"\"\n    try:\n        base = type(item)\n        kwargs = {'suffix': suffix, 'divider': divider, 'recursive': recursive}\n        tool = add_suffix if recursive else add_suffix_to_str\n        return base({tool(i, **kwargs) for i in item})\n    except TypeError:\n        return returns._process_return(\n            raise_error = raise_error,\n            message = f'item is not a supported type for {__name__}',\n            kind = 'set')\n</code></pre>"},{"location":"reference/modify/alter/affix/#modify.alter.affix.add_suffix_to_str","title":"<code>add_suffix_to_str(item, suffix, divider='', *, recursive=configuration.MISSING, raise_error=configuration.MISSING)</code>","text":"<p>Adds <code>prefix</code> to <code>item</code> with <code>divider</code> in between.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Any</code> <p>item to be modified.</p> required <code>suffix</code> <code>str</code> <p>suffix to be added to <code>item</code>.</p> required <code>divider</code> <code>str</code> <p><code>str</code> to add between <code>item</code> and <code>suffix</code>. Defaults to '', which means no divider will be added. <code>divider</code> is included as a convenience for loops, but if you are just making isolated calls, you can just add the divider to <code>suffix</code>.</p> <code>''</code> <code>recursive</code> <code>bool | MISSING</code> <p>ignored for <code>str</code> types because they cannot be nested.</p> <code>MISSING</code> <code>raise_error</code> <code>bool | MISSING</code> <p>whether to raise an error (True) or to return a default value based on the type of <code>item</code> (False), when possible. If the dispatcher cannot find an appropriate type, an error is always raised (since there is no matching default value). Defaults to <code>configuration.MISSING</code>, which means the global setting for <code>_RAISE_ERROR</code> will be used.</p> <code>MISSING</code> <p>Returns:</p> Type Description <code>Any</code> <p>Modified item.</p> Source code in <code>src/modify/alter/affix.py</code> <pre><code>@add_suffix.register(str)\ndef add_suffix_to_str(\n    item: Any,\n    suffix: str,\n    divider: str  = '', *,\n    recursive: bool | configuration.MISSING = configuration.MISSING,\n    raise_error: bool | configuration.MISSING = configuration.MISSING) -&gt; Any:\n    \"\"\"Adds `prefix` to `item` with `divider` in between.\n\n    Args:\n        item: item to be modified.\n        suffix: suffix to be added to `item`.\n        divider: `str` to add between `item` and `suffix`. Defaults to '', which\n            means no divider will be added. `divider` is included as a\n            convenience for loops, but if you are just making isolated calls,\n            you can just add the divider to `suffix`.\n        recursive: ignored for `str` types because they cannot be nested.\n        raise_error: whether to raise an error (True) or to return a default\n            value based on the type of `item` (False), when possible. If the\n            dispatcher cannot find an appropriate type, an error is always\n            raised (since there is no matching default value). Defaults to\n            `configuration.MISSING`, which means the global setting for\n            `_RAISE_ERROR` will be used.\n\n    Returns:\n        Modified item.\n\n    \"\"\"\n    try:\n        return divider.join([item, suffix])\n    except TypeError:\n        return returns._process_return(\n            raise_error = raise_error,\n            message = f'item is not a supported type for {__name__}',\n            kind = 'str')\n</code></pre>"},{"location":"reference/modify/alter/affix/#modify.alter.affix.add_suffix_to_tuple","title":"<code>add_suffix_to_tuple(item, suffix, divider='', *, recursive=configuration.MISSING, raise_error=configuration.MISSING)</code>","text":"<p>Adds <code>prefix</code> to <code>item</code> with <code>divider</code> in between.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Any</code> <p>item to be modified.</p> required <code>suffix</code> <code>str</code> <p>suffix to be added to <code>item</code>.</p> required <code>divider</code> <code>str</code> <p><code>str</code> to add between <code>item</code> and <code>suffix</code>. Defaults to '', which means no divider will be added. <code>divider</code> is included as a convenience for loops, but if you are just making isolated calls, you can just add the divider to <code>suffix</code>.</p> <code>''</code> <code>recursive</code> <code>bool | MISSING</code> <p>if <code>item</code> is nested, whether to apply the function to all nested objects as well (True) or merely the top level object (False). Defaults to <code>configuration.MISSING</code>, which means the global setting for <code>_RECURSIVE</code> will be used.</p> <code>MISSING</code> <code>raise_error</code> <code>bool | MISSING</code> <p>whether to raise an error (True) or to return a default value based on the type of <code>item</code> (False), when possible. If the dispatcher cannot find an appropriate type, an error is always raised (since there is no matching default value). Defaults to <code>configuration.MISSING</code>, which means the global setting for <code>_RAISE_ERROR</code> will be used.</p> <code>MISSING</code> <p>Returns:</p> Type Description <code>Any</code> <p>Modified <code>tuple</code>.</p> Source code in <code>src/modify/alter/affix.py</code> <pre><code>@add_suffix.register(tuple)\ndef add_suffix_to_tuple(\n    item: Any,\n    suffix: str,\n    divider: str  = '', *,\n    recursive: bool | configuration.MISSING = configuration.MISSING,\n    raise_error: bool | configuration.MISSING = configuration.MISSING) -&gt; Any:\n    \"\"\"Adds `prefix` to `item` with `divider` in between.\n\n    Args:\n        item: item to be modified.\n        suffix: suffix to be added to `item`.\n        divider: `str` to add between `item` and `suffix`. Defaults to '', which\n            means no divider will be added. `divider` is included as a\n            convenience for loops, but if you are just making isolated calls,\n            you can just add the divider to `suffix`.\n        recursive: if `item` is nested, whether to apply the function to all\n            nested objects as well (True) or merely the top level object\n            (False). Defaults to `configuration.MISSING`, which means the global\n            setting for `_RECURSIVE` will be used.\n        raise_error: whether to raise an error (True) or to return a default\n            value based on the type of `item` (False), when possible. If the\n            dispatcher cannot find an appropriate type, an error is always\n            raised (since there is no matching default value). Defaults to\n            `configuration.MISSING`, which means the global setting for\n            `_RAISE_ERROR` will be used.\n\n    Returns:\n        Modified `tuple`.\n\n    \"\"\"\n    try:\n        kwargs = {'suffix': suffix, 'divider': divider, 'recursive': recursive}\n        return tuple(add_suffix_to_list(item, **kwargs))\n    except TypeError:\n        return returns._process_return(\n            raise_error = raise_error,\n            message = f'item is not a supported type for {__name__}',\n            kind = 'tuple')\n</code></pre>"},{"location":"reference/modify/alter/divide/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> divide","text":"<p>Tools that divide an object into objects.</p> Contents <p>Dispatchers (tools that call other functions based on type passed):     cleave: divides an item into two parts at <code>divider</code>.     separate: divides an item into n+1 parts based at <code>divider</code>. Specific Tools:     cleave_str:     separate_str:</p> <p>To Do:</p>"},{"location":"reference/modify/alter/divide/#modify.alter.divide.cleave","title":"<code>cleave(item, divider, *, return_last=True, raise_error=False)</code>","text":"<p>Divides <code>item</code> into 2 parts based on <code>divider</code>.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Any</code> <p>item to be divided.</p> required <code>divider</code> <code>Any</code> <p>item to divide <code>item</code> upon.</p> required <code>return_last</code> <code>bool</code> <p>whether to split <code>item</code> upon the first (False) or last appearance of <code>divider</code>.</p> <code>True</code> <code>raise_error</code> <code>bool</code> <p>whether to raise an error if <code>divider</code> is not in <code>item</code> or to return a tuple containing <code>item</code> twice.</p> <code>False</code> <p>Returns:</p> Type Description <code>tuple[Any, Any]</code> <p>Parts of <code>item</code> on either side of <code>divider</code> unless <code>divider</code> is not in <code>item</code>.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>if no registered function supports the type of <code>item</code>.</p> Source code in <code>src/modify/alter/divide.py</code> <pre><code>@functools.singledispatch\ndef cleave(\n    item: Any,\n    divider: Any, *,\n    return_last: bool = True,\n    raise_error: bool = False) -&gt; tuple[Any, Any]:\n    \"\"\"Divides `item` into 2 parts based on `divider`.\n\n    Args:\n        item: item to be divided.\n        divider: item to divide `item` upon.\n        return_last: whether to split `item` upon the first (False) or last\n            appearance of `divider`.\n        raise_error: whether to raise an error if `divider` is not in `item` or\n            to return a tuple containing `item` twice.\n\n    Returns:\n        Parts of `item` on either side of `divider` unless `divider` is not in\n            `item`.\n\n    Raises:\n        TypeError: if no registered function supports the type of `item`.\n\n    \"\"\"\n    raise TypeError(f'item is not a supported type for {__name__}')\n</code></pre>"},{"location":"reference/modify/alter/divide/#modify.alter.divide.cleave_str","title":"<code>cleave_str(item, divider='_', *, return_last=True, raise_error=False)</code>","text":"<p>Divides <code>item</code> into 2 parts based on <code>divider</code>.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Any</code> <p>item to be divided.</p> required <code>divider</code> <code>Any</code> <p>item to divide <code>item</code> upon. Defaults to an underscore.</p> <code>'_'</code> <code>return_last</code> <code>bool</code> <p>whether to split <code>item</code> upon the first (False) or last appearance of <code>divider</code>.</p> <code>True</code> <code>raise_error</code> <code>bool</code> <p>whether to raise an error if <code>divider</code> is not in <code>item</code> or to return a tuple containing <code>item</code> twice.</p> <code>False</code> <p>Returns:</p> Type Description <code>tuple[Any, Any]</code> <p>Parts of <code>item</code> on either side of <code>divider</code> unless <code>divider</code> is not in <code>item</code>.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>if <code>divider</code> is not in <code>item</code> and <code>raise_error</code> is True.</p> Source code in <code>src/modify/alter/divide.py</code> <pre><code>@cleave.register\ndef cleave_str(\n    item: Any,\n    divider: Any = '_', *,\n    return_last: bool = True,\n    raise_error: bool = False) -&gt; tuple[Any, Any]:\n    \"\"\"Divides `item` into 2 parts based on `divider`.\n\n    Args:\n        item: item to be divided.\n        divider: item to divide `item` upon. Defaults to an underscore.\n        return_last: whether to split `item` upon the first (False) or last\n            appearance of `divider`.\n        raise_error: whether to raise an error if `divider` is not in `item` or\n            to return a tuple containing `item` twice.\n\n    Returns:\n        Parts of `item` on either side of `divider` unless `divider` is not in\n            `item`.\n\n    Raises:\n        ValueError: if `divider` is not in `item` and `raise_error` is True.\n\n    \"\"\"\n    if divider in item:\n        suffix = item.split(divider)[-1] if return_last else item.split(divider)[0]\n        prefix = item[:-len(suffix) - 1]\n    elif raise_error:\n        raise ValueError(f'{divider} is not in {item}')\n    else:\n        prefix = suffix = item\n    return prefix, suffix\n</code></pre>"},{"location":"reference/modify/alter/divide/#modify.alter.divide.separate","title":"<code>separate(item, divider, *, raise_error=False)</code>","text":"<p>Divides <code>item</code> into n+1 parts based on <code>divider</code>.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Any</code> <p>item to be divided.</p> required <code>divider</code> <code>Any</code> <p>item to divide <code>item</code> upon.</p> required <code>raise_error</code> <code>bool</code> <p>whether to raise an error if <code>divider</code> is not in <code>item</code> or to return a tuple containing <code>item</code> twice.</p> <code>False</code> <p>Raises:</p> Type Description <code>TypeError</code> <p>if no registered function supports the type of <code>item</code>.</p> <p>Returns:</p> Type Description <code>tuple[Any, ...]</code> <p>list[Any, ...]: parts of <code>item</code> on either side of <code>divider</code> unless <code>divider</code> is not in <code>item</code>.</p> Source code in <code>src/modify/alter/divide.py</code> <pre><code>@functools.singledispatch\ndef separate(\n    item: Any,\n    divider: Any, *,\n    raise_error: bool = False) -&gt; tuple[Any, ...]:\n    \"\"\"Divides `item` into n+1 parts based on `divider`.\n\n    Args:\n        item (Any): item to be divided.\n        divider (Any): item to divide `item` upon.\n        raise_error (bool): whether to raise an error if `divider` is not in\n            `item` or to return a tuple containing `item` twice.\n\n    Raises:\n        TypeError: if no registered function supports the type of `item`.\n\n    Returns:\n        list[Any, ...]: parts of `item` on either side of `divider` unless\n            `divider` is not in `item`.\n\n    \"\"\"\n    raise TypeError(f'item is not a supported type for {__name__}')\n</code></pre>"},{"location":"reference/modify/alter/divide/#modify.alter.divide.separate_str","title":"<code>separate_str(item, /, divider='_', raise_error=False)</code>","text":"<p>Divides 'item' into n+1 parts based on 'divider'.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>str</code> <p>item to be divided.</p> required <code>divider</code> <code>str</code> <p>item to divide 'item' upon.</p> <code>'_'</code> <code>raise_error</code> <code>bool</code> <p>whether to raise an error if 'divider' is not in 'item' or to return a tuple containing 'item' twice.</p> <code>False</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>if 'divider' is not in 'item' and 'raise_error' is True.</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>list[str]: parts of 'item' on either side of 'divider' unless 'divider' is not in 'item'.</p> Source code in <code>src/modify/alter/divide.py</code> <pre><code>@separate.register\ndef separate_str(\n    item: str, /,\n    divider: str = '_',\n    raise_error: bool = False) -&gt; list[str]:\n    \"\"\"Divides 'item' into n+1 parts based on 'divider'.\n\n    Args:\n        item (str): item to be divided.\n        divider (str): item to divide 'item' upon.\n        raise_error (bool): whether to raise an error if 'divider' is not in\n            'item' or to return a tuple containing 'item' twice.\n\n    Raises:\n        ValueError: if 'divider' is not in 'item' and 'raise_error' is True.\n\n    Returns:\n        list[str]: parts of 'item' on either side of 'divider' unless 'divider'\n            is not in 'item'.\n\n    \"\"\"\n    if divider in item:\n        return item.split(divider)\n    elif raise_error:\n        raise ValueError(f'{divider} is not in {item}')\n    else:\n        return [item]\n</code></pre>"},{"location":"reference/modify/alter/remove/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> remove","text":"<p>Tools that remove things from objects.</p> Contents <p>General Tools (tools that call other functions based on type passed):     drop_dunders: removes attributes or data from an item that begin with         double underscores.     drop_duplicates: removes duplicates from an item.     drop_prefix: removes a <code>str</code> prefix from an item.     drop_privates: removes attributes or data from an item that begins with         at least one underscore.     drop_substring: removes substring from an item.     drop_suffix: removes a <code>str</code> suffix from an item. Specific Tools:     drop_dunders_from_object: removes items from a class, instance, or         module if the attribute or variable names begin with double         underscores.     drop_dunders_from_dict: removes items from a <code>dict</code>-like object if the         key begins with double underscores.     drop_dunders_from_list: removes items from a <code>list</code>-like object if they         begin with double underscores.     drop_duplicates_from_dict: drops duplicates from a <code>dict</code>-like object.     drop_duplicates_from_list: drops duplicates from a <code>list</code>-like object.     drop_duplicates_from_str: drops duplicate letters from a <code>str</code>.     drop_duplicates_tuple: drops duplicates from a <code>tuple</code>-like object.     drop_prefix_from_dict: drops a <code>str</code> prefix from a <code>dict</code>-like object.     drop_prefix_from_list: drops a <code>str</code> prefix from a <code>list</code>-like object.     drop_prefix_from_set: drops a <code>str</code> prefix from a <code>set</code>-like object.     drop_prefix_from_str: drops a <code>str</code> prefix from a <code>str</code>.     drop_prefix_tuple: drops a <code>str</code> prefix from a <code>tuple</code>-like object.     drop_privates_from_object: removes items from a class, instance, or         module if the attribute or variable names begin with at least one         underscores.     drop_privates_from_dict: removes items from a <code>dict</code>-like object if the         key begins with at least one underscores.     drop_privates_from_list: removes items from a <code>list</code>-like object if they         begin with at least one underscores.     drop_substring_from_dict: drops a <code>str</code> substring from a <code>dict</code>-like         object.     drop_substring_from_list: drops a <code>str</code> substring from a <code>list</code>-like         object.     drop_substring_from_set: drops a <code>str</code> substring from a <code>set</code>-like         object.     drop_substring_from_str: drops a <code>str</code> substring from a <code>str</code>.     drop_substring_from_tuple: drops a <code>str</code> substring from a <code>tuple</code>-like         object.     drop_suffix_from_dict: drops a <code>str</code> suffix from a <code>dict</code>-like object.     drop_suffix_from_list: drops a <code>str</code> suffix from a <code>list</code>-like object.     drop_suffix_from_set: drops a <code>str</code> suffix from a <code>set</code>-like object.     drop_suffix_from_str: drops a <code>str</code> suffix from a <code>str</code>.     drop_suffix_from_tuple: drops a <code>str</code> suffix from a <code>tuple</code>-like object.</p> <p>To Do:</p>"},{"location":"reference/modify/alter/remove/#modify.alter.remove.drop_dunders","title":"<code>drop_dunders(item)</code>","text":"<p>Drops items in 'item' beginning with a double underscore.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Any</code> <p>item to modify.</p> required <p>Returns:</p> Name Type Description <code>Any</code> <code>Any</code> <p>item with entries dropped beginning with a double underscore.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>if 'item' is not a registered type.</p> Source code in <code>src/modify/alter/remove.py</code> <pre><code>@functools.singledispatch\ndef drop_dunders(item: Any, /) -&gt; Any:\n    \"\"\"Drops items in 'item' beginning with a double underscore.\n\n    Args:\n        item (Any): item to modify.\n\n    Returns:\n        Any: item with entries dropped beginning with a double underscore.\n\n    Raises:\n        TypeError: if 'item' is not a registered type.\n\n    \"\"\"\n    raise TypeError(f'item is not a supported type for {__name__}')\n</code></pre>"},{"location":"reference/modify/alter/remove/#modify.alter.remove.drop_dunders_dict","title":"<code>drop_dunders_dict(item)</code>","text":"<p>Drops items in 'item' beginning with a double underscore.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Mapping[str, Any]</code> <p>dict-like object with str keys that might have double underscores at the beginning of the key names.</p> required <p>Returns:</p> Type Description <code>Mapping[str, Any]</code> <p>Mapping[str, Any]: dict-luke object with entries dropped if the key name begin with a double underscore.</p> Source code in <code>src/modify/alter/remove.py</code> <pre><code>@drop_dunders.register(Mapping)\ndef drop_dunders_dict(item: Mapping[str, Any], /) -&gt; Mapping[str, Any]:\n    \"\"\"Drops items in 'item' beginning with a double underscore.\n\n    Args:\n        item (Mapping[str, Any]): dict-like object with str keys that might have\n            double underscores at the beginning of the key names.\n\n    Returns:\n        Mapping[str, Any]: dict-luke object with entries dropped if the key name\n            begin with a double underscore.\n\n    \"\"\"\n    base = type(item)\n    return base({k: v for k, v in item.items() if not k.startswith('__')})\n</code></pre>"},{"location":"reference/modify/alter/remove/#modify.alter.remove.drop_dunders_list","title":"<code>drop_dunders_list(item)</code>","text":"<p>Drops items in 'item' beginning with a double underscore.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>MutableSequence[str | object]</code> <p>list-like object with str items or names that might have double underscores at their beginnings.</p> required <p>Returns:</p> Type Description <code>MutableSequence[str | object]</code> <p>MutableSequence[str | object]: list-like object with items dropped if they or their names begin with a double underscore.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>if 'item' does not contain str types or objects with either 'name' or 'name' attributes.</p> Source code in <code>src/modify/alter/remove.py</code> <pre><code>@drop_dunders.register(MutableSequence)\ndef drop_dunders_list(\n    item: MutableSequence[str | object], /) -&gt; MutableSequence[str | object]:\n    \"\"\"Drops items in 'item' beginning with a double underscore.\n\n    Args:\n        item (MutableSequence[str | object]): list-like object with str items or\n            names that might have double underscores at their beginnings.\n\n    Returns:\n        MutableSequence[str | object]: list-like object with items dropped if\n            they or their names begin with a double underscore.\n\n    Raises:\n        TypeError: if 'item' does not contain str types or objects with either\n            'name' or '__name__' attributes.\n\n    \"\"\"\n    base = type(item)\n    if len(item) &gt; 0 and all(isinstance(i, str) for i in item):\n        return base([i for i in item if not i.startswith('__')])\n    elif len(item) &gt; 0 and all(hasattr(i, 'name') for i in item):\n        return base([i for i in item if not i.name.startswith('__')])\n    elif len(item) &gt; 0 and all(hasattr(i, '__name__') for i in item):\n        return base([i for i in item if not i.__name__.startswith('__')])\n    elif len == 0:\n        return item\n    else:\n        raise TypeError(\n            'items in item must be str types or have name or __name__ '\n            'attributes')\n</code></pre>"},{"location":"reference/modify/alter/remove/#modify.alter.remove.drop_duplicates","title":"<code>drop_duplicates(item)</code>","text":"<p>Deduplicates contents of 'item.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Any</code> <p>item to deduplicate.</p> required <p>Raises:</p> Type Description <code>TypeError</code> <p>if no registered function supports the type of 'item'.</p> <p>Returns:</p> Name Type Description <code>Any</code> <code>Any</code> <p>deduplicated item.</p> Source code in <code>src/modify/alter/remove.py</code> <pre><code>@functools.singledispatch\ndef drop_duplicates(item: Any, /) -&gt; Any:\n    \"\"\"Deduplicates contents of 'item.\n\n    Args:\n        item (Any): item to deduplicate.\n\n    Raises:\n        TypeError: if no registered function supports the type of 'item'.\n\n    Returns:\n        Any: deduplicated item.\n\n    \"\"\"\n    raise TypeError(f'item is not a supported type for {__name__}')\n</code></pre>"},{"location":"reference/modify/alter/remove/#modify.alter.remove.drop_duplicates_list","title":"<code>drop_duplicates_list(item)</code>","text":"<p>Deduplicates contents of 'item.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>MutableSequence[Any]</code> <p>item to deduplicate.</p> required <p>Returns:</p> Type Description <code>MutableSequence[Any]</code> <p>MutableSequence[Any]: deduplicated item.</p> Source code in <code>src/modify/alter/remove.py</code> <pre><code>@drop_duplicates.register(MutableSequence)\ndef drop_duplicates_list(item: MutableSequence[Any], /) -&gt; MutableSequence[Any]:\n    \"\"\"Deduplicates contents of 'item.\n\n    Args:\n        item (MutableSequence[Any]): item to deduplicate.\n\n    Returns:\n        MutableSequence[Any]: deduplicated item.\n\n    \"\"\"\n    base = type(item)\n    contents = list(dict.fromkeys(item))\n    return base(contents)\n</code></pre>"},{"location":"reference/modify/alter/remove/#modify.alter.remove.drop_duplicates_tuple","title":"<code>drop_duplicates_tuple(item)</code>","text":"<p>Deduplicates contents of 'item.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>tuple[Any, ...]</code> <p>item to deduplicate.</p> required <p>Returns:</p> Type Description <code>tuple[Any, ...]</code> <p>tuple[Any, ...]: deduplicated item.</p> Source code in <code>src/modify/alter/remove.py</code> <pre><code>@drop_duplicates.register(tuple)\ndef drop_duplicates_tuple(item: tuple[Any, ...], /) -&gt; tuple[Any, ...]:\n    \"\"\"Deduplicates contents of 'item.\n\n    Args:\n        item (tuple[Any, ...]): item to deduplicate.\n\n    Returns:\n        tuple[Any, ...]: deduplicated item.\n\n    \"\"\"\n    return tuple(drop_duplicates_list(item))\n</code></pre>"},{"location":"reference/modify/alter/remove/#modify.alter.remove.drop_prefix","title":"<code>drop_prefix(item, prefix, divider='', *, recursive=configuration.MISSING, raise_error=configuration.MISSING)</code>","text":"<p>Adds <code>prefix</code> to <code>item</code> with <code>divider</code> in between.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Any</code> <p>item to be modified.</p> required <code>prefix</code> <code>str</code> <p>prefix to be dropped from <code>item</code>.</p> required <code>divider</code> <code>str</code> <p><code>str</code> to add between <code>item</code> and <code>prefix</code>. Defaults to '', which means no divider will be added. <code>divider</code> is included as a convenience for loops, but if you are just making isolated calls, you can just add the divider to <code>prefix</code>.</p> <code>''</code> <code>recursive</code> <code>bool | MISSING</code> <p>if <code>item</code> is nested, whether to apply the function to all nested objects as well (True) or merely the top level object (False). Defaults to <code>configuration.MISSING</code>, which means the global setting for <code>_RECURSIVE</code> will be used.</p> <code>MISSING</code> <code>raise_error</code> <code>bool | MISSING</code> <p>whether to raise an error (True) or to return a default value based on the type of <code>item</code> (False), when possible. If the dispatcher cannot find an appropriate type, an error is always raised (since there is no matching default value). Defaults to <code>configuration.MISSING</code>, which means the global setting for <code>_RAISE_ERROR</code> will be used.</p> <code>MISSING</code> <p>Returns:</p> Type Description <code>Any</code> <p>Modified item.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>if no registered function supports the type of <code>item</code>.</p> Source code in <code>src/modify/alter/remove.py</code> <pre><code>@functools.singledispatch\ndef drop_prefix(\n    item: Any,\n    prefix: str,\n    divider: str  = '', *,\n    recursive: bool | configuration.MISSING = configuration.MISSING,\n    raise_error: bool | configuration.MISSING = configuration.MISSING) -&gt; Any:\n    \"\"\"Adds `prefix` to `item` with `divider` in between.\n\n    Args:\n        item: item to be modified.\n        prefix: prefix to be dropped from `item`.\n        divider: `str` to add between `item` and `prefix`. Defaults to '', which\n            means no divider will be added. `divider` is included as a\n            convenience for loops, but if you are just making isolated calls,\n            you can just add the divider to `prefix`.\n        recursive: if `item` is nested, whether to apply the function to all\n            nested objects as well (True) or merely the top level object\n            (False). Defaults to `configuration.MISSING`, which means the global\n            setting for `_RECURSIVE` will be used.\n        raise_error: whether to raise an error (True) or to return a default\n            value based on the type of `item` (False), when possible. If the\n            dispatcher cannot find an appropriate type, an error is always\n            raised (since there is no matching default value). Defaults to\n            `configuration.MISSING`, which means the global setting for\n            `_RAISE_ERROR` will be used.\n\n    Returns:\n        Modified item.\n\n    Raises:\n        TypeError: if no registered function supports the type of `item`.\n\n    \"\"\"\n    return returns._process_return(\n        raise_error = raise_error,\n        message = f'item is not a supported type for {__name__}',\n        item = item)\n</code></pre>"},{"location":"reference/modify/alter/remove/#modify.alter.remove.drop_prefix_from_dict","title":"<code>drop_prefix_from_dict(item, /, prefix, divider='')</code>","text":"<p>Drops 'prefix' from keys in 'item' with 'divider' in between.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Mapping[str, Any]</code> <p>item to be modified.</p> required <code>prefix</code> <code>str</code> <p>prefix to be added to 'item'.</p> required <code>divider</code> <code>str</code> <p>str to add between 'item' and 'prefix'. Defaults to '', which means no divider will be added.</p> <code>''</code> <p>Returns:</p> Type Description <code>Mapping[str, Any]</code> <p>Mapping[str, Any]: modified mapping.</p> Source code in <code>src/modify/alter/remove.py</code> <pre><code>@drop_prefix.register(Mapping)\ndef drop_prefix_from_dict(\n    item: Mapping[str, Any], /,\n    prefix: str,\n    divider: str = '') -&gt; Mapping[str, Any]:\n    \"\"\"Drops 'prefix' from keys in 'item' with 'divider' in between.\n\n    Args:\n        item (Mapping[str, Any]): item to be modified.\n        prefix (str): prefix to be added to 'item'.\n        divider (str): str to add between 'item' and 'prefix'. Defaults to '',\n            which means no divider will be added.\n\n    Returns:\n        Mapping[str, Any]: modified mapping.\n\n    \"\"\"\n    contents = {\n        drop_prefix(item = k, prefix = prefix, divider = divider): v\n        for k, v in item.items()}\n    return contents if isinstance(item, dict) else item.__class__(contents)\n</code></pre>"},{"location":"reference/modify/alter/remove/#modify.alter.remove.drop_prefix_from_list","title":"<code>drop_prefix_from_list(item, /, prefix, divider='')</code>","text":"<p>Drops 'prefix' from items in 'item' with 'divider' in between.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>MutableSequence[str]</code> <p>item to be modified.</p> required <code>prefix</code> <code>str</code> <p>prefix to be added to 'item'.</p> required <code>divider</code> <code>str</code> <p>str to add between 'item' and 'prefix'. Defaults to '', which means no divider will be added.</p> <code>''</code> <p>Returns:</p> Type Description <code>MutableSequence[str]</code> <p>MutableSequence[str]: modified sequence.</p> Source code in <code>src/modify/alter/remove.py</code> <pre><code>@drop_prefix.register(MutableSequence)\ndef drop_prefix_from_list(\n    item: MutableSequence[str], /,\n    prefix: str,\n    divider: str = '') -&gt; MutableSequence[str]:\n    \"\"\"Drops 'prefix' from items in 'item' with 'divider' in between.\n\n    Args:\n        item (MutableSequence[str]): item to be modified.\n        prefix (str): prefix to be added to 'item'.\n        divider (str): str to add between 'item' and 'prefix'. Defaults to '',\n            which means no divider will be added.\n\n    Returns:\n        MutableSequence[str]: modified sequence.\n\n    \"\"\"\n    contents = [\n        drop_prefix(item = i, prefix = prefix, divider = divider) for i in item]\n    return contents if isinstance(item, list) else item.__class__(contents)\n</code></pre>"},{"location":"reference/modify/alter/remove/#modify.alter.remove.drop_prefix_from_set","title":"<code>drop_prefix_from_set(item, /, prefix, divider='')</code>","text":"<p>Drops 'prefix' from items in 'item' with 'divider' in between.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Set[str]</code> <p>item to be modified.</p> required <code>prefix</code> <code>str</code> <p>prefix to be added to 'item'.</p> required <code>divider</code> <code>str</code> <p>str to add between 'item' and 'prefix'. Defaults to '', which means no divider will be added.</p> <code>''</code> <p>Returns:</p> Type Description <code>Set[str]</code> <p>Set[str]: modified set.</p> Source code in <code>src/modify/alter/remove.py</code> <pre><code>@drop_prefix.register(AbstractSet)\ndef drop_prefix_from_set(\n    item: AbstractSet[str], /,\n    prefix: str,\n    divider: str = '') -&gt; AbstractSet[str]:\n    \"\"\"Drops 'prefix' from items in 'item' with 'divider' in between.\n\n    Args:\n        item (Set[str]): item to be modified.\n        prefix (str): prefix to be added to 'item'.\n        divider (str): str to add between 'item' and 'prefix'. Defaults to '',\n            which means no divider will be added.\n\n    Returns:\n        Set[str]: modified set.\n\n    \"\"\"\n    contents = {\n        drop_prefix(item = i, prefix = prefix, divider = divider) for i in item}\n    return contents if isinstance(item, set) else item.__class__(contents)\n</code></pre>"},{"location":"reference/modify/alter/remove/#modify.alter.remove.drop_prefix_from_str","title":"<code>drop_prefix_from_str(item, /, prefix, divider='')</code>","text":"<p>Drops 'prefix' from 'item' with 'divider' in between.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>str</code> <p>item to be modified.</p> required <code>prefix</code> <code>str</code> <p>prefix to be added to 'item'.</p> required <code>divider</code> <code>str</code> <p>str to add between 'item' and 'prefix'. Defaults to '', which means no divider will be added.</p> <code>''</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>modified str.</p> Source code in <code>src/modify/alter/remove.py</code> <pre><code>@drop_prefix.register\ndef drop_prefix_from_str(item: str, /, prefix: str, divider: str = '') -&gt; str:\n    \"\"\"Drops 'prefix' from 'item' with 'divider' in between.\n\n    Args:\n        item (str): item to be modified.\n        prefix (str): prefix to be added to 'item'.\n        divider (str): str to add between 'item' and 'prefix'. Defaults to '',\n            which means no divider will be added.\n\n    Returns:\n        str: modified str.\n\n    \"\"\"\n    prefix = ''.join([prefix, divider])\n    if item.startswith(prefix):\n        return item[len(prefix):]\n    else:\n        return item\n</code></pre>"},{"location":"reference/modify/alter/remove/#modify.alter.remove.drop_prefix_from_tuple","title":"<code>drop_prefix_from_tuple(item, /, prefix, divider='')</code>","text":"<p>Drops 'prefix' from items in 'item' with 'divider' in between.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>tuple[str, ...]</code> <p>item to be modified.</p> required <code>prefix</code> <code>str</code> <p>prefix to be added to 'item'.</p> required <code>divider</code> <code>str</code> <p>str to add between 'item' and 'prefix'. Defaults to '', which means no divider will be added.</p> <code>''</code> <p>Returns:</p> Type Description <code>tuple[str, ...]</code> <p>tuple[str, ...]: modified tuple.</p> Source code in <code>src/modify/alter/remove.py</code> <pre><code>@drop_prefix.register(tuple)\ndef drop_prefix_from_tuple(\n    item: tuple[str, ...], /,\n    prefix: str,\n    divider: str = '') -&gt; tuple[str, ...]:\n    \"\"\"Drops 'prefix' from items in 'item' with 'divider' in between.\n\n    Args:\n        item (tuple[str, ...]): item to be modified.\n        prefix (str): prefix to be added to 'item'.\n        divider (str): str to add between 'item' and 'prefix'. Defaults to '',\n            which means no divider will be added.\n\n    Returns:\n        tuple[str, ...]: modified tuple.\n\n    \"\"\"\n    return tuple(\n        drop_prefix(item=i, prefix=prefix, divider=divider) for i in item)\n</code></pre>"},{"location":"reference/modify/alter/remove/#modify.alter.remove.drop_privates","title":"<code>drop_privates(item)</code>","text":"<p>Drops items in 'item' with names beginning with an underscore.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Any</code> <p>item to modify.</p> required <p>Returns:</p> Name Type Description <code>Any</code> <code>Any</code> <p>item with entries dropped beginning with an underscore.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>if 'item' is not a registered type.</p> Source code in <code>src/modify/alter/remove.py</code> <pre><code>@functools.singledispatch\ndef drop_privates(item: Any, /) -&gt; Any:\n    \"\"\"Drops items in 'item' with names beginning with an underscore.\n\n    Args:\n        item (Any): item to modify.\n\n    Returns:\n        Any: item with entries dropped beginning with an underscore.\n\n    Raises:\n        TypeError: if 'item' is not a registered type.\n\n    \"\"\"\n    raise TypeError(f'item is not a supported type for {__name__}')\n</code></pre>"},{"location":"reference/modify/alter/remove/#modify.alter.remove.drop_privates_dict","title":"<code>drop_privates_dict(item)</code>","text":"<p>Drops items in 'item' with key names beginning with an underscore.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Mapping[str, Any]</code> <p>dict-like object with str keys that might have underscores at the beginning of the key names.</p> required <p>Returns:</p> Type Description <code>Mapping[str, Any]</code> <p>Mapping[str, Any]: dict-luke object with entries dropped if the key name begin with an underscore.</p> Source code in <code>src/modify/alter/remove.py</code> <pre><code>@drop_privates.register(Mapping)\ndef drop_privates_dict(item: Mapping[str, Any], /) -&gt; Mapping[str, Any]:\n    \"\"\"Drops items in 'item' with key names beginning with an underscore.\n\n    Args:\n        item (Mapping[str, Any]): dict-like object with str keys that might have\n            underscores at the beginning of the key names.\n\n    Returns:\n        Mapping[str, Any]: dict-luke object with entries dropped if the key name\n            begin with an underscore.\n\n    \"\"\"\n    base = type(item)\n    return base({k: v for k, v in item.items() if not k.startswith('_')})\n</code></pre>"},{"location":"reference/modify/alter/remove/#modify.alter.remove.drop_privates_list","title":"<code>drop_privates_list(item)</code>","text":"<p>Drops items in 'item' with names beginning with an underscore.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>MutableSequence[str | object]</code> <p>list-like object with str items or names that might have underscores at their beginnings.</p> required <p>Returns:</p> Type Description <code>MutableSequence[str | object]</code> <p>MutableSequence[str | object]: list-like object with items dropped if they or their names begin with an underscore.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>if 'item' does not contain str types or objects with either 'name' or 'name' attributes.</p> Source code in <code>src/modify/alter/remove.py</code> <pre><code>@drop_privates.register(MutableSequence)\ndef drop_privates_list(\n    item: MutableSequence[str | object], /) -&gt; MutableSequence[str | object]:\n    \"\"\"Drops items in 'item' with names beginning with an underscore.\n\n    Args:\n        item (MutableSequence[str | object]): list-like object with str items or\n            names that might have underscores at their beginnings.\n\n    Returns:\n        MutableSequence[str | object]: list-like object with items dropped if\n            they or their names begin with an underscore.\n\n    Raises:\n        TypeError: if 'item' does not contain str types or objects with either\n            'name' or '__name__' attributes.\n\n    \"\"\"\n    base = type(item)\n    if len(item) &gt; 0 and all(isinstance(i, str) for i in item):\n        return base([i for i in item if not i.startswith('_')])\n    elif len(item) &gt; 0 and all(hasattr(i, 'name') for i in item):\n        return base([i for i in item if not i.name.startswith('_')])\n    elif len(item) &gt; 0 and all(hasattr(i, '__name__') for i in item):\n        return base([i for i in item if not i.__name__.startswith('_')])\n    elif len == 0:\n        return item\n    else:\n        raise TypeError(\n            'items in item must be str types or have name or __name__ '\n            'attributes')\n</code></pre>"},{"location":"reference/modify/alter/remove/#modify.alter.remove.drop_substring","title":"<code>drop_substring(item, /, substring)</code>","text":"<p>Drops 'substring' from 'item' with a possible 'divider' in between.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Any</code> <p>item to be modified.</p> required <code>substring</code> <code>str</code> <p>substring to be added to 'item'.</p> required <p>Raises:</p> Type Description <code>TypeError</code> <p>if no registered function supports the type of 'item'.</p> <p>Returns:</p> Name Type Description <code>Any</code> <code>Any</code> <p>modified item.</p> Source code in <code>src/modify/alter/remove.py</code> <pre><code>@functools.singledispatch\ndef drop_substring(item: Any, /, substring: str) -&gt; Any:\n    \"\"\"Drops 'substring' from 'item' with a possible 'divider' in between.\n\n    Args:\n        item (Any): item to be modified.\n        substring (str): substring to be added to 'item'.\n\n    Raises:\n        TypeError: if no registered function supports the type of 'item'.\n\n    Returns:\n        Any: modified item.\n\n    \"\"\"\n    raise TypeError(f'item is not a supported type for {__name__}')\n</code></pre>"},{"location":"reference/modify/alter/remove/#modify.alter.remove.drop_substring_from_dict","title":"<code>drop_substring_from_dict(item, /, substring)</code>","text":"<p>Drops 'substring' from keys in 'item'.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Mapping[str, Any]</code> <p>item to be modified.</p> required <code>substring</code> <code>str</code> <p>substring to be added to 'item'.</p> required <p>Returns:</p> Type Description <code>Mapping[str, Any]</code> <p>Mapping[str, Any]: modified mapping.</p> Source code in <code>src/modify/alter/remove.py</code> <pre><code>@drop_substring.register(Mapping)\ndef drop_substring_from_dict(\n    item: Mapping[str, Any], /,\n    substring: str) -&gt; Mapping[str, Any]:\n    \"\"\"Drops 'substring' from keys in 'item'.\n\n    Args:\n        item (Mapping[str, Any]): item to be modified.\n        substring (str): substring to be added to 'item'.\n\n    Returns:\n        Mapping[str, Any]: modified mapping.\n\n    \"\"\"\n    contents = {\n        drop_substring(item = k, substring = substring): v\n        for k, v in item.items()}\n    return contents if isinstance(item, dict) else item.__class__(contents)\n</code></pre>"},{"location":"reference/modify/alter/remove/#modify.alter.remove.drop_substring_from_list","title":"<code>drop_substring_from_list(item, /, substring)</code>","text":"<p>Drops 'substring' from items in 'item'.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>MutableSequence[str]</code> <p>item to be modified.</p> required <code>substring</code> <code>str</code> <p>substring to be added to 'item'.</p> required <p>Returns:</p> Type Description <code>MutableSequence[str]</code> <p>MutableSequence[str]: modified sequence.</p> Source code in <code>src/modify/alter/remove.py</code> <pre><code>@drop_substring.register(MutableSequence)\ndef drop_substring_from_list(\n    item: MutableSequence[str], /,\n    substring: str) -&gt; MutableSequence[str]:\n    \"\"\"Drops 'substring' from items in 'item'.\n\n    Args:\n        item (MutableSequence[str]): item to be modified.\n        substring (str): substring to be added to 'item'.\n\n    Returns:\n        MutableSequence[str]: modified sequence.\n\n    \"\"\"\n    contents = [drop_substring(item = i, substring = substring) for i in item]\n    return contents if isinstance(item, list) else item.__class__(contents)\n</code></pre>"},{"location":"reference/modify/alter/remove/#modify.alter.remove.drop_substring_from_set","title":"<code>drop_substring_from_set(item, /, substring)</code>","text":"<p>Drops 'substring' from items in 'item'.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Set[str]</code> <p>item to be modified.</p> required <code>substring</code> <code>str</code> <p>substring to be added to 'item'.</p> required <p>Returns:</p> Type Description <code>Set[str]</code> <p>Set[str]: modified set.</p> Source code in <code>src/modify/alter/remove.py</code> <pre><code>@drop_substring.register(AbstractSet)\ndef drop_substring_from_set(item: AbstractSet[str], /, substring: str) -&gt; AbstractSet[str]:\n    \"\"\"Drops 'substring' from items in 'item'.\n\n    Args:\n        item (Set[str]): item to be modified.\n        substring (str): substring to be added to 'item'.\n\n    Returns:\n        Set[str]: modified set.\n\n    \"\"\"\n    contents = {drop_substring(item = i, substring = substring) for i in item}\n    return contents if isinstance(item, set) else item.__class__(contents)\n</code></pre>"},{"location":"reference/modify/alter/remove/#modify.alter.remove.drop_substring_from_str","title":"<code>drop_substring_from_str(item, /, substring)</code>","text":"<p>Drops 'substring' from 'item'.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>str</code> <p>item to be modified.</p> required <code>substring</code> <code>str</code> <p>substring to be added to 'item'.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>modified str.</p> Source code in <code>src/modify/alter/remove.py</code> <pre><code>@drop_substring.register\ndef drop_substring_from_str(item: str, /, substring: str) -&gt; str:\n    \"\"\"Drops 'substring' from 'item'.\n\n    Args:\n        item (str): item to be modified.\n        substring (str): substring to be added to 'item'.\n\n    Returns:\n        str: modified str.\n\n    \"\"\"\n    return item.replace(substring, '') if substring in item else item\n</code></pre>"},{"location":"reference/modify/alter/remove/#modify.alter.remove.drop_substring_from_tuple","title":"<code>drop_substring_from_tuple(item, /, substring)</code>","text":"<p>Drops 'substring' from items in 'item'.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>tuple[str, ...]</code> <p>item to be modified.</p> required <code>substring</code> <code>str</code> <p>substring to be added to 'item'.</p> required <p>Returns:</p> Type Description <code>tuple[str, ...]</code> <p>tuple[str, ...]: modified tuple.</p> Source code in <code>src/modify/alter/remove.py</code> <pre><code>@drop_substring.register(tuple)\ndef drop_substring_from_tuple(\n    item: tuple[str, ...], /,\n    substring: str) -&gt; tuple[str, ...]:\n    \"\"\"Drops 'substring' from items in 'item'.\n\n    Args:\n        item (tuple[str, ...]): item to be modified.\n        substring (str): substring to be added to 'item'.\n\n    Returns:\n        tuple[str, ...]: modified tuple.\n\n    \"\"\"\n    return tuple(drop_substring(item = i, substring = substring) for i in item)\n</code></pre>"},{"location":"reference/modify/alter/remove/#modify.alter.remove.drop_suffix","title":"<code>drop_suffix(item, /, suffix, divider='')</code>","text":"<p>Drops 'suffix' from 'item' with 'divider' in between.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Any</code> <p>item to be modified.</p> required <code>suffix</code> <code>str</code> <p>suffix to be added to 'item'.</p> required <p>Raises:</p> Type Description <code>TypeError</code> <p>if no registered function supports the type of 'item'.</p> <p>Returns:</p> Name Type Description <code>Any</code> <code>Any</code> <p>modified item.</p> Source code in <code>src/modify/alter/remove.py</code> <pre><code>@functools.singledispatch\ndef drop_suffix(item: Any, /, suffix: str, divider: str = '') -&gt; Any:\n    \"\"\"Drops 'suffix' from 'item' with 'divider' in between.\n\n    Args:\n        item (Any): item to be modified.\n        suffix (str): suffix to be added to 'item'.\n\n    Raises:\n        TypeError: if no registered function supports the type of 'item'.\n\n    Returns:\n        Any: modified item.\n\n    \"\"\"\n    raise TypeError(f'item is not a supported type for {__name__}')\n</code></pre>"},{"location":"reference/modify/alter/remove/#modify.alter.remove.drop_suffix_from_dict","title":"<code>drop_suffix_from_dict(item, /, suffix, divider='')</code>","text":"<p>Drops 'suffix' from keys in 'item' with 'divider' in between.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Mapping[str, Any]</code> <p>item to be modified.</p> required <code>suffix</code> <code>str</code> <p>suffix to be added to 'item'.</p> required <p>Returns:</p> Type Description <code>Mapping[str, Any]</code> <p>Mapping[str, Any]: modified mapping.</p> Source code in <code>src/modify/alter/remove.py</code> <pre><code>@drop_suffix.register(Mapping)\ndef drop_suffix_from_dict(\n    item: Mapping[str, Any], /,\n    suffix: str,\n    divider: str = '') -&gt; Mapping[str, Any]:\n    \"\"\"Drops 'suffix' from keys in 'item' with 'divider' in between.\n\n    Args:\n        item (Mapping[str, Any]): item to be modified.\n        suffix (str): suffix to be added to 'item'.\n\n    Returns:\n        Mapping[str, Any]: modified mapping.\n\n    \"\"\"\n    contents = {\n        drop_suffix(item = k, suffix = suffix, divider = divider): v\n        for k, v in item.items()}\n    return contents if isinstance(item, dict) else item.__class__(contents)\n</code></pre>"},{"location":"reference/modify/alter/remove/#modify.alter.remove.drop_suffix_from_list","title":"<code>drop_suffix_from_list(item, /, suffix, divider='')</code>","text":"<p>Drops 'suffix' from items in 'item' with 'divider' in between.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>MutableSequence[str]</code> <p>item to be modified.</p> required <code>suffix</code> <code>str</code> <p>suffix to be added to 'item'.</p> required <p>Returns:</p> Type Description <code>MutableSequence[str]</code> <p>MutableSequence[str]: modified sequence.</p> Source code in <code>src/modify/alter/remove.py</code> <pre><code>@drop_suffix.register(MutableSequence)\ndef drop_suffix_from_list(\n    item: MutableSequence[str], /,\n    suffix: str,\n    divider: str = '') -&gt; MutableSequence[str]:\n    \"\"\"Drops 'suffix' from items in 'item' with 'divider' in between.\n\n    Args:\n        item (MutableSequence[str]): item to be modified.\n        suffix (str): suffix to be added to 'item'.\n\n    Returns:\n        MutableSequence[str]: modified sequence.\n\n    \"\"\"\n    contents = [\n        drop_suffix(item = i, suffix = suffix, divider = divider) for i in item]\n    return contents if isinstance(item, list) else item.__class__(contents)\n</code></pre>"},{"location":"reference/modify/alter/remove/#modify.alter.remove.drop_suffix_from_set","title":"<code>drop_suffix_from_set(item, /, suffix, divider='')</code>","text":"<p>Drops 'suffix' from items in 'item' with 'divider' in between.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Set[str]</code> <p>item to be modified.</p> required <code>suffix</code> <code>str</code> <p>suffix to be added to 'item'.</p> required <p>Returns:</p> Type Description <code>Set[str]</code> <p>Set[str]: modified set.</p> Source code in <code>src/modify/alter/remove.py</code> <pre><code>@drop_suffix.register(AbstractSet)\ndef drop_suffix_from_set(\n    item: AbstractSet[str], /,\n    suffix: str,\n    divider: str = '') -&gt; AbstractSet[str]:\n    \"\"\"Drops 'suffix' from items in 'item' with 'divider' in between.\n\n    Args:\n        item (Set[str]): item to be modified.\n        suffix (str): suffix to be added to 'item'.\n\n    Returns:\n        Set[str]: modified set.\n\n    \"\"\"\n    contents = {\n        drop_suffix(item = i, suffix = suffix, divider = divider) for i in item}\n    return contents if isinstance(item, set) else item.__class__(contents)\n</code></pre>"},{"location":"reference/modify/alter/remove/#modify.alter.remove.drop_suffix_from_str","title":"<code>drop_suffix_from_str(item, /, suffix, divider='')</code>","text":"<p>Drops 'suffix' from 'item' with 'divider' in between.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>str</code> <p>item to be modified.</p> required <code>suffix</code> <code>str</code> <p>suffix to be added to 'item'.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>modified str.</p> Source code in <code>src/modify/alter/remove.py</code> <pre><code>@drop_suffix.register\ndef drop_suffix_from_str(item: str, /, suffix: str, divider: str = '') -&gt; str:\n    \"\"\"Drops 'suffix' from 'item' with 'divider' in between.\n\n    Args:\n        item (str): item to be modified.\n        suffix (str): suffix to be added to 'item'.\n\n    Returns:\n        str: modified str.\n\n    \"\"\"\n    suffix = ''.join([suffix, divider])\n    return item.removesuffix(suffix) if item.endswith(suffix) else item\n</code></pre>"},{"location":"reference/modify/alter/remove/#modify.alter.remove.drop_suffix_from_tuple","title":"<code>drop_suffix_from_tuple(item, /, suffix, divider='')</code>","text":"<p>Drops 'suffix' from items in 'item' with 'divider' in between.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>tuple[str, ...]</code> <p>item to be modified.</p> required <code>suffix</code> <code>str</code> <p>suffix to be added to 'item'.</p> required <p>Returns:</p> Type Description <code>tuple[str, ...]</code> <p>tuple[str, ...]: modified tuple.</p> Source code in <code>src/modify/alter/remove.py</code> <pre><code>@drop_suffix.register(tuple)\ndef drop_suffix_from_tuple(\n    item: tuple[str, ...], /,\n    suffix: str,\n    divider: str = '') -&gt; tuple[str, ...]:\n    \"\"\"Drops 'suffix' from items in 'item' with 'divider' in between.\n\n    Args:\n        item (tuple[str, ...]): item to be modified.\n        suffix (str): suffix to be added to 'item'.\n\n    Returns:\n        tuple[str, ...]: modified tuple.\n\n    \"\"\"\n    return tuple(\n        drop_suffix(item=i, suffix=suffix, divider=divider) for i in item)\n</code></pre>"},{"location":"reference/modify/alter/tinker/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> tinker","text":"<p>Tools that reorganize objects but do not change the object's type.</p> Contents <p>Dispatchers (tools that call other functions based on type passed):     capitalify: converts data from a snake case <code>str</code> to capital case.     snakify: converts data from a capital case <code>str</code> to snake case. Specific Tools:     capitalify_dict: converts keys in a <code>dict</code>-like object to capital case.     capitalify_list: converts items in a <code>list</code>-like object to capital case.     capitalify_set: converts items in a <code>set</code>-like object to capital case.     capitalify_str: converts a <code>str</code> to capital case.     capitalify_tuple: converts items in a <code>tuple</code>-like object to capital         case.     snakify_dict: converts keys in a <code>dict</code>-like object to snake case.     snakify_list: converts items in a <code>list</code>-like object to snake case.     snakify_set: converts items in a <code>set</code>-like object to snake case.     snakify_str: converts a <code>str</code> to snake case.     snakify_tuple: converts items in a <code>tuple</code>-like object to snake case.     windowify: Returns a sliding window of a sequence of <code>length</code> over         <code>item</code>.</p> <p>To Do:</p>"},{"location":"reference/modify/alter/tinker/#modify.alter.tinker.capitalify","title":"<code>capitalify(item)</code>","text":"<p>Converts a snake case str to capital case.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>str</code> <p>str to convert.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>'item' converted to capital case.</p> Source code in <code>src/modify/alter/tinker.py</code> <pre><code>def capitalify(item: str) -&gt; str:\n    \"\"\"Converts a snake case str to capital case.\n\n    Args:\n        item (str): str to convert.\n\n    Returns:\n        str: 'item' converted to capital case.\n\n    \"\"\"\n    return item.replace('_', ' ').title().replace(' ', '')\n</code></pre>"},{"location":"reference/modify/alter/tinker/#modify.alter.tinker.snakify","title":"<code>snakify(item)</code>","text":"<p>Converts a capitalized str to snake case.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>str</code> <p>str to convert.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>'item' converted to snake case.</p> Source code in <code>src/modify/alter/tinker.py</code> <pre><code>def snakify(item: str) -&gt; str:\n    \"\"\"Converts a capitalized str to snake case.\n\n    Args:\n        item (str): str to convert.\n\n    Returns:\n        str: 'item' converted to snake case.\n\n    \"\"\"\n    item = re.sub('(.)([A-Z][a-z]+)', r'\\1_\\2', item)\n    return re.sub('([a-z0-9])([A-Z])', r'\\1_\\2', item).lower()\n</code></pre>"},{"location":"reference/modify/alter/tinker/#modify.alter.tinker.windowify","title":"<code>windowify(item, length, fill_value=None, step=1)</code>","text":"<p>Returns a sliding window of <code>length</code> over <code>item</code>.</p> <p>This code is adapted from more_itertools.windowed to remove a dependency.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Sequence[Any]</code> <p>sequence from which to return windows.</p> required <code>length</code> <code>int</code> <p>length of window.</p> required <code>fill_value</code> <code>Optional[Any]</code> <p>value to use for items in a window that do not exist when length &gt; len(item). Defaults to None.</p> <code>None</code> <code>step</code> <code>Optional[Any]</code> <p>number of items to advance between each window. Defaults to 1.</p> <code>1</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>if <code>length</code> is less than 0 or step is less than 1.</p> <p>Returns:</p> Type Description <code>Sequence[Any]</code> <p>Sequence[Any]: windowed sequence derived from arguments.</p> Source code in <code>src/modify/alter/tinker.py</code> <pre><code>def windowify(\n    item: Sequence[Any],\n    length: int,\n    fill_value: Any | None = None,\n    step: int | None = 1) -&gt; Sequence[Any]:\n    \"\"\"Returns a sliding window of `length` over `item`.\n\n    This code is adapted from more_itertools.windowed to remove a dependency.\n\n    Args:\n        item (Sequence[Any]): sequence from which to return windows.\n        length (int): length of window.\n        fill_value (Optional[Any]): value to use for items in a window that do\n            not exist when length &gt; len(item). Defaults to None.\n        step (Optional[Any]): number of items to advance between each window.\n            Defaults to 1.\n\n    Raises:\n        ValueError: if `length` is less than 0 or step is less than 1.\n\n    Returns:\n        Sequence[Any]: windowed sequence derived from arguments.\n\n    \"\"\"\n    if length &lt; 0:\n        raise ValueError('length must be &gt;= 0')\n    if length == 0:\n        yield ()\n        return\n    if step &lt; 1:\n        raise ValueError('step must be &gt;= 1')\n    window = collections.deque(maxlen = length)\n    i = length\n    for _ in map(window.append, item):\n        i -= 1\n        if not i:\n            i = step\n            yield tuple(window)\n    size = len(window)\n    if size &lt; length:\n        yield tuple(itertools.chain(\n            window, itertools.repeat(fill_value, length - size)))\n    elif 0 &lt; i &lt; min(step, length):\n        window += (fill_value,) * i\n        yield tuple(window)\n</code></pre>"},{"location":"reference/modify/convert/","title":"Index","text":"<p>Python tools for transforming objects.</p>"},{"location":"reference/modify/convert/classes/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> classes","text":"<p>Functions that convert types.</p> Contents <p>dictify: converts to or validates a dict. hashify: converts to or validates a hashable object. instancify: converts to or validates an instance. If it is already an     instance, any passed kwargs are added as attributes to the instance. integerify: converts to or validates an int. iterify: converts to or validates an iterable. kwargify: uses annotations to turn positional arguments into keyword     arguments. listify: converts to or validates a list. namify: returns hashable name for passed item. numify: converts to or validates a numerical type. pathlibify: converts to or validates a pathlib.Path. stringify: converts to or validates a str. tuplify: converts to or validates a tuple. typify: converts a str type to other common types, if possible. windowify: Returns a sliding window of <code>length</code> over <code>item</code>. to_dict: to_index str_to_index to_int str_to_int float_to_int to_list str_to_list to_float int_to_float str_to_float to_path str_to_path to_str int_to_str float_to_str list_to_str none_to_str path_to_str datetime_to_str</p> To Do <p>Add more flexible tools.</p>"},{"location":"reference/modify/convert/classes/#modify.convert.classes.instancify","title":"<code>instancify(item, **kwargs)</code>","text":"<p>Returns <code>item</code> as an instance with <code>kwargs</code> as parameters/attributes.</p> <p>If <code>item</code> is already an instance, kwargs are added as attributes to the existing <code>item</code>. This will overwrite any existing attributes of the same name.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Type[Any] | object</code> <p>class to make an instance out of by passing kwargs or an instance to add kwargs to as attributes.</p> required <p>Raises:</p> Type Description <code>TypeError</code> <p>if <code>item</code> is neither a class nor instance.</p> <p>Returns:</p> Name Type Description <code>object</code> <code>Any</code> <p>a class instance with <code>kwargs</code> as attributes or passed as parameters (if <code>item</code> is a class).</p> Source code in <code>src/modify/convert/classes.py</code> <pre><code>def instancify(item: type[Any] | object, **kwargs: Any) -&gt; Any:\n    \"\"\"Returns `item` as an instance with `kwargs` as parameters/attributes.\n\n    If `item` is already an instance, kwargs are added as attributes to the\n    existing `item`. This will overwrite any existing attributes of the same\n    name.\n\n    Args:\n        item (Type[Any] | object)): class to make an instance out of by\n            passing kwargs or an instance to add kwargs to as attributes.\n\n    Raises:\n        TypeError: if `item` is neither a class nor instance.\n\n    Returns:\n        object: a class instance with `kwargs` as attributes or passed as\n            parameters (if `item` is a class).\n\n    \"\"\"\n    if inspect.isclass(item):\n        return item(**kwargs)\n    elif isinstance(item, object):\n        for key, value in kwargs.items():\n            setattr(item, key, value)\n        return item\n    else:\n        raise TypeError('item must be a class or class instance')\n</code></pre>"},{"location":"reference/modify/convert/hashes/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> hashes","text":"<p>Tools that convert to Hashable types.</p> Contents <p>hashify: converts to or validates a hashable object. dict_to_hash: converts a <code>dict</code> to a <code>tuple</code> with keys and values. list_to_hash: converts a <code>list</code> to a <code>tuple</code> of its values.</p> <p>To Do:</p>"},{"location":"reference/modify/convert/hashes/#modify.convert.hashes.dict_to_hash","title":"<code>dict_to_hash(item)</code>","text":"<p>Converts <code>item</code> to a Hashable tuple with keys and values.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>MutableMapping[Hashable, Any]</code> <p>item to convert to a Hashable.</p> required <p>Returns:</p> Type Description <code>Hashable</code> <p>Hashable tuple with keys and values derived from <code>item</code>.</p> Source code in <code>src/modify/convert/hashes.py</code> <pre><code>@hashify.register(MutableMapping)\ndef dict_to_hash(item: MutableMapping[Hashable, Any]) -&gt; Hashable:\n    \"\"\"Converts `item` to a Hashable tuple with keys and values.\n\n    Args:\n        item: item to convert to a Hashable.\n\n    Returns:\n        Hashable tuple with keys and values derived from `item`.\n\n    \"\"\"\n    keys, values = tuple(item.keys()), tuple(item.values())\n    return tuple(keys, values)\n</code></pre>"},{"location":"reference/modify/convert/hashes/#modify.convert.hashes.hashify","title":"<code>hashify(item, /, default=MISSING)</code>","text":"<p>Converts <code>item</code> to a Hashable.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Any</code> <p>item to convert to a Hashable.</p> required <p>Raises:</p> Type Description <code>TypeError</code> <p>if <code>item</code> is a type that is not registered.</p> <p>Returns:</p> Name Type Description <code>Hashable</code> <code>Hashable</code> <p>derived from 'item'.</p> Source code in <code>src/modify/convert/hashes.py</code> <pre><code>@functools.singledispatch\ndef hashify(item: Any, /, default: Any = MISSING) -&gt; Hashable:\n    \"\"\"Converts `item` to a Hashable.\n\n    Args:\n        item (Any): item to convert to a Hashable.\n\n    Raises:\n        TypeError: if `item` is a type that is not registered.\n\n    Returns:\n        Hashable: derived from 'item'.\n\n    \"\"\"\n    if isinstance(item, Hashable):\n        return item\n    else:\n        raise TypeError(\n        f'item cannot be converted because it is an unsupported type: '\n        f'{type(item).__name__}')\n</code></pre>"},{"location":"reference/modify/convert/hashes/#modify.convert.hashes.list_to_hash","title":"<code>list_to_hash(item)</code>","text":"<p>Converts <code>item</code> to a Hashable tuple with keys and values.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>MutableSequence[Any]</code> <p>item to convert to a Hashable.</p> required <p>Returns:</p> Type Description <code>Hashable</code> <p>Hashable tuple with keys and values derived from <code>item</code>.</p> Source code in <code>src/modify/convert/hashes.py</code> <pre><code>@hashify.register(MutableSequence)\ndef list_to_hash(item: MutableSequence[Any]) -&gt; Hashable:\n    \"\"\"Converts `item` to a Hashable tuple with keys and values.\n\n    Args:\n        item: item to convert to a Hashable.\n\n    Returns:\n        Hashable tuple with keys and values derived from `item`.\n\n    \"\"\"\n    return tuple(item)\n</code></pre>"},{"location":"reference/modify/convert/mappings/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> mappings","text":"<p>Tools that convert to <code>dict</code> types.</p> Contents <p>dictify: converts to or validates a <code>dict</code>. lists_to_dict: converts two lists of equal length to keys and values in a     <code>dict</code>. str_to_dict: attempts to use <code>ast.literal_eval</code> to turn a <code>str</code> into a     <code>dict</code>.</p>"},{"location":"reference/modify/convert/mappings/#modify.convert.mappings.dictify","title":"<code>dictify(item)</code>","text":"<p>Converts <code>item</code> to a MutableMapping.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Any</code> <p>item to convert to a MutableMapping.</p> required <p>Raises:</p> Type Description <code>TypeError</code> <p>if <code>item</code> is a type that is not registered.</p> <p>Returns:</p> Type Description <code>MutableMapping[Hashable, Any]</code> <p>MutableMapping derived from <code>item</code>.</p> Source code in <code>src/modify/convert/mappings.py</code> <pre><code>@functools.singledispatch\ndef dictify(item: Any, /) -&gt; MutableMapping[Hashable, Any]:\n    \"\"\"Converts `item` to a MutableMapping.\n\n    Args:\n        item: item to convert to a MutableMapping.\n\n    Raises:\n        TypeError: if `item` is a type that is not registered.\n\n    Returns:\n        MutableMapping derived from `item`.\n\n    \"\"\"\n    if isinstance(item, MutableMapping):\n        return item\n    else:\n        raise TypeError(\n        f'item cannot be converted because it is an unsupported type: '\n        f'{type(item).__name__}')\n</code></pre>"},{"location":"reference/modify/convert/mappings/#modify.convert.mappings.lists_to_dict","title":"<code>lists_to_dict(item)</code>","text":"<p>Converts <code>item</code> to a MutableMapping.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Sequence[Sequence[Any]]</code> <p>item to convert to a MutableMapping.</p> required <p>Returns:</p> Type Description <code>MutableMapping[Hashable, Any]</code> <p>MutableMapping derived from <code>item</code>.</p> Source code in <code>src/modify/convert/mappings.py</code> <pre><code>@dictify.register(Sequence)\ndef lists_to_dict(\n    item: Sequence[Sequence[Any]]) -&gt; MutableMapping[Hashable, Any]:\n    \"\"\"Converts `item` to a MutableMapping.\n\n    Args:\n        item: item to convert to a MutableMapping.\n\n    Returns:\n        MutableMapping derived from `item`.\n\n    \"\"\"\n    return dict(zip(item[0], item[1]))\n</code></pre>"},{"location":"reference/modify/convert/mappings/#modify.convert.mappings.str_to_dict","title":"<code>str_to_dict(item)</code>","text":"<p>Converts <code>item</code> to a MutableMapping.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>str</code> <p>item to convert to a MutableMapping.</p> required <p>Raises:</p> Type Description <code>TypeError</code> <p>if <code>item</code> is converted, but not to a MutableMapping.</p> <code>ValueError</code> <p>if <code>item</code> cannot be converted to a <code>dict</code>.</p> <p>Returns:</p> Type Description <code>MutableMapping[Hashable, Any]</code> <p>MutableMapping derived from <code>item</code>.</p> Source code in <code>src/modify/convert/mappings.py</code> <pre><code>@dictify.register(Sequence)\ndef str_to_dict(item: str) -&gt; MutableMapping[Hashable, Any]:\n    \"\"\"Converts `item` to a MutableMapping.\n\n    Args:\n        item: item to convert to a MutableMapping.\n\n    Raises:\n        TypeError: if `item` is converted, but not to a MutableMapping.\n        ValueError: if `item` cannot be converted to a `dict`.\n\n    Returns:\n        MutableMapping derived from `item`.\n\n    \"\"\"\n    try:\n        converted = ast.literal_eval(item)\n        if isinstance(converted, MutableMapping):\n            return converted\n        message = f'{item} could not be converted to a dict'\n        raise TypeError(message)\n    except ValueError as error:\n        message = f'{item} could not be converted to a dict'\n        raise ValueError(message) from error\n</code></pre>"},{"location":"reference/modify/convert/numbers/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> numbers","text":"<p>Tools that convert to numerical types.</p> Contents <p>integerify: converts to or validates an int. numify: converts to or validates a numerical type. str_to_int float_to_int int_to_float str_to_float</p> <p>To Do:</p>"},{"location":"reference/modify/convert/numbers/#modify.convert.numbers.float_to_int","title":"<code>float_to_int(item)</code>","text":"<p>Converts <code>item</code> to an int.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>float</code> <p>item to convert.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>derived from <code>item</code>.</p> Source code in <code>src/modify/convert/numbers.py</code> <pre><code>@integerify.register\ndef float_to_int(item: float, /) -&gt; int:\n    \"\"\"Converts `item` to an int.\n\n    Args:\n        item (float): item to convert.\n\n    Returns:\n        int: derived from `item`.\n\n    \"\"\"\n    return int(item)\n</code></pre>"},{"location":"reference/modify/convert/numbers/#modify.convert.numbers.int_to_float","title":"<code>int_to_float(item)</code>","text":"<p>[summary]</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>int</code> <p>[description]</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>[description]</p> Source code in <code>src/modify/convert/numbers.py</code> <pre><code>def int_to_float(item: int, /) -&gt; float:\n    \"\"\"[summary]\n\n    Args:\n        item (int): [description]\n\n    Returns:\n        float: [description]\n    \"\"\"\n    \"\"\"Converts an int to a float.\"\"\"\n    return float(item)\n</code></pre>"},{"location":"reference/modify/convert/numbers/#modify.convert.numbers.integerify","title":"<code>integerify(item)</code>","text":"<p>Converts <code>item</code> to an int.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Any</code> <p>item to convert.</p> required <p>Raises:</p> Type Description <code>TypeError</code> <p>if <code>item</code> is a type that cannot be converted.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>derived from <code>item</code>.</p> Source code in <code>src/modify/convert/numbers.py</code> <pre><code>@functools.singledispatch\ndef integerify(item: Any, /) -&gt; int:\n    \"\"\"Converts `item` to an int.\n\n    Args:\n        item (Any): item to convert.\n\n    Raises:\n        TypeError: if `item` is a type that cannot be converted.\n\n    Returns:\n        int: derived from `item`.\n\n    \"\"\"\n    if isinstance(item, int):\n        return item\n    else:\n        raise TypeError(\n            f'item cannot be converted because it is an '\n            f'unsupported type: {type(item).__name__}')\n</code></pre>"},{"location":"reference/modify/convert/numbers/#modify.convert.numbers.numify","title":"<code>numify(item, raise_error=False)</code>","text":"<p>Converts <code>item</code> to a numeric type.</p> <p>If <code>item</code> cannot be converted to a numeric type and <code>raise_error</code> is False,     <code>item</code> is returned as is.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>str</code> <p>item to be converted.</p> required <code>raise_error</code> <code>bool</code> <p>whether to raise a TypeError when conversion to a numeric type fails (True) or to simply return <code>item</code> (False). Defaults to False.</p> <code>False</code> <p>Raises:</p> Type Description <code>TypeError</code> <p>if <code>item</code> cannot be converted to a numeric type and <code>raise_error</code> is True.</p> <p>Returns:</p> Type Description <code>int | float | Any</code> <p>int | float | Any: converted to numeric type, if possible.</p> Source code in <code>src/modify/convert/numbers.py</code> <pre><code>@functools.singledispatch\ndef numify(item: Any, raise_error: bool = False) -&gt; int | float | Any:\n    \"\"\"Converts `item` to a numeric type.\n\n    If `item` cannot be converted to a numeric type and `raise_error` is False,\n        `item` is returned as is.\n\n    Args:\n        item (str): item to be converted.\n        raise_error (bool): whether to raise a TypeError when conversion to a\n            numeric type fails (True) or to simply return `item` (False).\n            Defaults to False.\n\n    Raises:\n        TypeError: if `item` cannot be converted to a numeric type and\n            `raise_error` is True.\n\n    Returns:\n        int | float | Any: converted to numeric type, if possible.\n\n    \"\"\"\n    try:\n        return int(item)\n    except ValueError:\n        try:\n            return float(item)\n        except ValueError:\n            if raise_error:\n                raise TypeError(\n                    f'{item} not able to be converted to a numeric type')\n            else:\n                return item\n</code></pre>"},{"location":"reference/modify/convert/numbers/#modify.convert.numbers.str_to_float","title":"<code>str_to_float(item)</code>","text":"<p>[summary]</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>str</code> <p>[description]</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>[description]</p> Source code in <code>src/modify/convert/numbers.py</code> <pre><code>def str_to_float(item: str, /) -&gt; float:\n    \"\"\"[summary]\n\n    Args:\n        item (str): [description]\n\n    Returns:\n        float: [description]\n    \"\"\"\n    \"\"\"Converts a str to a float.\"\"\"\n    return float(item)\n</code></pre>"},{"location":"reference/modify/convert/numbers/#modify.convert.numbers.str_to_int","title":"<code>str_to_int(item)</code>","text":"<p>Converts <code>item</code> to an int.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>str</code> <p>item to convert.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>derived from <code>item</code>.</p> Source code in <code>src/modify/convert/numbers.py</code> <pre><code>@integerify.register\ndef str_to_int(item: str, /) -&gt; int:\n    \"\"\"Converts `item` to an int.\n\n    Args:\n        item (str): item to convert.\n\n    Returns:\n        int: derived from `item`.\n\n    \"\"\"\n    return int(item)\n</code></pre>"},{"location":"reference/modify/convert/numbers/#modify.convert.numbers.to_float","title":"<code>to_float(item)</code>","text":"<p>Converts <code>item</code> to a float.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Any</code> <p>item to convert to a float.</p> required <p>Raises:</p> Type Description <code>TypeError</code> <p>if <code>item</code> is a type that is not registered.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>derived from <code>item</code>.</p> Source code in <code>src/modify/convert/numbers.py</code> <pre><code>def to_float(item: Any, /) -&gt; float:\n    \"\"\"Converts `item` to a float.\n\n    Args:\n        item (Any): item to convert to a float.\n\n    Raises:\n        TypeError: if `item` is a type that is not registered.\n\n    Returns:\n        float: derived from `item`.\n\n    \"\"\"\n    if isinstance(item, float):\n        return item\n    else:\n        raise TypeError(\n            f'item cannot be converted because it is an unsupported type: '\n            f'{type(item).__name__}')\n</code></pre>"},{"location":"reference/modify/convert/parameters/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> parameters","text":"<p>Tools that convert to arg or kwarg formats.</p> Contents <p>dictify: converts to or validates a dict. hashify: converts to or validates a hashable object. instancify: converts to or validates an instance. If it is already an     instance, any passed kwargs are added as attributes to the instance. integerify: converts to or validates an int. iterify: converts to or validates an iterable. kwargify: uses annotations to turn positional arguments into keyword     arguments. listify: converts to or validates a list. namify: returns hashable name for passed item. numify: converts to or validates a numerical type. pathlibify: converts to or validates a pathlib.Path. stringify: converts to or validates a str. tuplify: converts to or validates a tuple. typify: converts a str type to other common types, if possible. windowify: Returns a sliding window of <code>length</code> over <code>item</code>. to_dict: to_index str_to_index to_int str_to_int float_to_int to_list str_to_list to_float int_to_float str_to_float to_path str_to_path to_str int_to_str float_to_str list_to_str none_to_str path_to_str datetime_to_str</p> To Do <p>Add more flexible tools.</p>"},{"location":"reference/modify/convert/parameters/#modify.convert.parameters.kwargify","title":"<code>kwargify(item, /, args)</code>","text":"<p>Converts args to kwargs.</p> <p>item (Type): the item with annotations used to construct kwargs.     args (tuple): arguments without keywords passed to <code>item</code>.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>if there are more args than annotations in <code>item</code>.</p> <p>Returns:</p> Type Description <code>dict[Hashable, Any]</code> <p>dict[Hashable, Any]: kwargs based on <code>args</code> and <code>item</code>.</p> Source code in <code>src/modify/convert/parameters.py</code> <pre><code>def kwargify(item: type[Any], /, args: tuple[Any]) -&gt; dict[Hashable, Any]:\n    \"\"\"Converts args to kwargs.\n\n    Args:\n    item (Type): the item with annotations used to construct kwargs.\n        args (tuple): arguments without keywords passed to `item`.\n\n    Raises:\n        ValueError: if there are more args than annotations in `item`.\n\n    Returns:\n        dict[Hashable, Any]: kwargs based on `args` and `item`.\n\n    \"\"\"\n    annotations = list(item.__annotations__.keys())\n    if len(args) &gt; len(annotations):\n        raise ValueError('There are too many args for item')\n    else:\n        return dict(zip(annotations, args))\n</code></pre>"},{"location":"reference/modify/convert/paths/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> paths","text":"<p>Tools that convert to <code>pathlib.Path</code> types.</p> Contents <p>pathlibify: converts to or validates a pathlib.Path. str_to_path</p> <p>To Do:</p>"},{"location":"reference/modify/convert/paths/#modify.convert.paths.pathify","title":"<code>pathify(item)</code>","text":"<p>Converts string <code>path</code> to pathlib.Path object.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>str | Path</code> <p>either a string summary of a path or a pathlib.Path object.</p> required <p>Returns:</p> Type Description <code>Path</code> <p>pathlib.Path object.</p> Source code in <code>src/modify/convert/paths.py</code> <pre><code>@functools.singledispatch\ndef pathify(item: Any, /) -&gt; pathlib.Path:\n    \"\"\"Converts string `path` to pathlib.Path object.\n\n    Args:\n        item (str | pathlib.Path): either a string summary of a path or a\n            pathlib.Path object.\n\n    Raises:\n        TypeError if `path` is neither a str or pathlib.Path type.\n\n    Returns:\n        pathlib.Path object.\n\n    \"\"\"\n    if isinstance(item, pathlib.Path):\n        return item\n    else:\n        raise TypeError(\n            f'item cannot be converted because it is an unsupported type: '\n            f'{type(item).__name__}')\n</code></pre>"},{"location":"reference/modify/convert/paths/#modify.convert.paths.str_to_path","title":"<code>str_to_path(item)</code>","text":"<p>[summary]</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>str</code> <p>[description]</p> required <p>Returns:</p> Type Description <code>Path</code> <p>pathlib.Path: [description]</p> Source code in <code>src/modify/convert/paths.py</code> <pre><code>@pathify.register\ndef str_to_path(item: str, /) -&gt; pathlib.Path:\n    \"\"\"[summary]\n\n    Args:\n        item (str): [description]\n\n    Returns:\n        pathlib.Path: [description]\n    \"\"\"\n    return pathlib.Path(item)\n</code></pre>"},{"location":"reference/modify/convert/sequences/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> sequences","text":"<p>Tools that convert to <code>list</code> or <code>tuple</code> types.</p> Contents <p>dictify: converts to or validates a dict. hashify: converts to or validates a hashable object. instancify: converts to or validates an instance. If it is already an     instance, any passed kwargs are added as attributes to the instance. integerify: converts to or validates an int. iterify: converts to or validates an iterable. kwargify: uses annotations to turn positional arguments into keyword     arguments. listify: converts to or validates a list. namify: returns hashable name for passed item. numify: converts to or validates a numerical type. pathlibify: converts to or validates a pathlib.Path. stringify: converts to or validates a str. tuplify: converts to or validates a tuple. typify: converts a str type to other common types, if possible. windowify: Returns a sliding window of <code>length</code> over <code>item</code>. to_dict: to_index str_to_index to_int str_to_int float_to_int to_list str_to_list to_float int_to_float str_to_float to_path str_to_path to_str int_to_str float_to_str list_to_str none_to_str path_to_str datetime_to_str</p> To Do <p>Add more flexible tools.</p>"},{"location":"reference/modify/convert/sequences/#modify.convert.sequences.datetime_to_string","title":"<code>datetime_to_string(item, /, time_format='%Y-%m-%d_%H-%M')</code>","text":"<p>Return datetime <code>item</code> as a str based on <code>time_format</code>.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>datetime</code> <p>datetime object to convert to a str.</p> required <code>time_format</code> <code>Optional[str]</code> <p>format to create a str from datetime. The passed argument should follow the rules of datetime.strftime. Defaults to '%Y-%m-%d_%H-%M'.</p> <code>'%Y-%m-%d_%H-%M'</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>converted datetime <code>item</code>.</p> Source code in <code>src/modify/convert/sequences.py</code> <pre><code>def datetime_to_string(\n    item: datetime.datetime, /,\n    time_format: str | None = '%Y-%m-%d_%H-%M') -&gt; str:\n    \"\"\"Return datetime `item` as a str based on `time_format`.\n\n    Args:\n        item (datetime.datetime): datetime object to convert to a str.\n        time_format (Optional[str]): format to create a str from datetime. The\n            passed argument should follow the rules of datetime.strftime.\n            Defaults to '%Y-%m-%d_%H-%M'.\n\n    Returns:\n        str: converted datetime `item`.\n\n    \"\"\"\n    return item.strftime(time_format)\n</code></pre>"},{"location":"reference/modify/convert/sequences/#modify.convert.sequences.float_to_str","title":"<code>float_to_str(item)</code>","text":"<p>[summary]</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>float</code> <p>[description]</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>[description]</p> Source code in <code>src/modify/convert/sequences.py</code> <pre><code>def float_to_str(item: float, /) -&gt; str:\n    \"\"\"[summary]\n\n    Args:\n        item (float): [description]\n\n    Returns:\n        str: [description]\n    \"\"\"\n    \"\"\"Converts an float to a str.\"\"\"\n    return str(item)\n</code></pre>"},{"location":"reference/modify/convert/sequences/#modify.convert.sequences.int_to_float","title":"<code>int_to_float(item)</code>","text":"<p>[summary]</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>int</code> <p>[description]</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>[description]</p> Source code in <code>src/modify/convert/sequences.py</code> <pre><code>def int_to_float(item: int, /) -&gt; float:\n    \"\"\"[summary]\n\n    Args:\n        item (int): [description]\n\n    Returns:\n        float: [description]\n    \"\"\"\n    \"\"\"Converts an int to a float.\"\"\"\n    return float(item)\n</code></pre>"},{"location":"reference/modify/convert/sequences/#modify.convert.sequences.int_to_str","title":"<code>int_to_str(item)</code>","text":"<p>[summary]</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>int</code> <p>[description]</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>[description]</p> Source code in <code>src/modify/convert/sequences.py</code> <pre><code>def int_to_str(item: int, /) -&gt; str:\n    \"\"\"[summary]\n\n    Args:\n        item (int): [description]\n\n    Returns:\n        str: [description]\n    \"\"\"\n    \"\"\"Converts an int to a str.\"\"\"\n    return str(item)\n</code></pre>"},{"location":"reference/modify/convert/sequences/#modify.convert.sequences.iterify","title":"<code>iterify(item)</code>","text":"<p>Returns <code>item</code> as an iterable, but does not iterate str types.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Any</code> <p>item to turn into an iterable</p> required <p>Returns:</p> Name Type Description <code>Iterable</code> <code>Iterable</code> <p>of <code>item</code>. A str type will be stored as a single item in an Iterable wrapper.</p> Source code in <code>src/modify/convert/sequences.py</code> <pre><code>@functools.singledispatch\ndef iterify(item: Any, /) -&gt; Iterable:\n    \"\"\"Returns `item` as an iterable, but does not iterate str types.\n\n    Args:\n        item (Any): item to turn into an iterable\n\n    Returns:\n        Iterable: of `item`. A str type will be stored as a single item in an\n            Iterable wrapper.\n\n    \"\"\"\n    if item is None:\n        return iter(())\n    elif isinstance(item, (str, bytes)):\n        return iter([item])\n    else:\n        try:\n            return iter(item)\n        except TypeError:\n            return iter((item,))\n</code></pre>"},{"location":"reference/modify/convert/sequences/#modify.convert.sequences.list_to_str","title":"<code>list_to_str(item)</code>","text":"<p>[summary]</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>list[Any]</code> <p>[description]</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>[description]</p> Source code in <code>src/modify/convert/sequences.py</code> <pre><code>def list_to_str(item: list[Any], /) -&gt; str:\n    \"\"\"[summary]\n\n    Args:\n        item (list[Any]): [description]\n\n    Returns:\n        str: [description]\n    \"\"\"\n    \"\"\"Converts a list to a str.\"\"\"\n    return ', '.join(item)\n</code></pre>"},{"location":"reference/modify/convert/sequences/#modify.convert.sequences.listify","title":"<code>listify(item, /, default=None)</code>","text":"<p>Returns passed item as a list (if not already a list).</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Any</code> <p>item to be transformed into a list to allow proper iteration.</p> required <code>default</code> <code>Optional[Any]</code> <p>the default value to return if <code>item</code> is None. Unfortunately, to indicate you want None to be the default value, you need to put <code>None</code> in quotes. If not passed, <code>default</code> is set to [].</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Any</code> <code>Any</code> <p>a passed list, <code>item</code> converted to a list, or the <code>default</code> argument.</p> Source code in <code>src/modify/convert/sequences.py</code> <pre><code>@functools.singledispatch\ndef listify(item: Any, /, default: Any | None = None) -&gt; Any:\n    \"\"\"Returns passed item as a list (if not already a list).\n\n    Args:\n        item (Any): item to be transformed into a list to allow proper\n            iteration.\n        default (Optional[Any]): the default value to return if `item` is None.\n            Unfortunately, to indicate you want None to be the default value,\n            you need to put `None` in quotes. If not passed, `default` is set to\n            [].\n\n    Returns:\n        Any: a passed list, `item` converted to a list, or the `default`\n            argument.\n\n    \"\"\"\n    if item is None:\n        if default is None:\n            return []\n        elif default in ['None', 'none']:\n            return None\n        else:\n            return default\n    elif isinstance(item, MutableSequence) and not isinstance(item, str):\n        return item\n    else:\n        return [item]\n</code></pre>"},{"location":"reference/modify/convert/sequences/#modify.convert.sequences.none_to_str","title":"<code>none_to_str(item)</code>","text":"<p>[summary]</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>None</code> <p>[description]</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>[description]</p> Source code in <code>src/modify/convert/sequences.py</code> <pre><code>def none_to_str(item: None, /) -&gt; str:\n    \"\"\"[summary]\n\n    Args:\n        item (None): [description]\n\n    Returns:\n        str: [description]\n    \"\"\"\n    \"\"\"Converts None to a str.\"\"\"\n    return 'None'\n</code></pre>"},{"location":"reference/modify/convert/sequences/#modify.convert.sequences.path_to_str","title":"<code>path_to_str(item)</code>","text":"<p>Converts a pathlib.Path to a str.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Path</code> <p>[description]</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>[description]</p> Source code in <code>src/modify/convert/sequences.py</code> <pre><code>def path_to_str(item: pathlib.Path, /) -&gt; str:\n    \"\"\"Converts a pathlib.Path to a str.\n\n    Args:\n        item (pathlib.Path): [description]\n\n    Returns:\n        str: [description]\n\n    \"\"\"\n    return str(item)\n</code></pre>"},{"location":"reference/modify/convert/sequences/#modify.convert.sequences.str_to_float","title":"<code>str_to_float(item)</code>","text":"<p>[summary]</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>str</code> <p>[description]</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>[description]</p> Source code in <code>src/modify/convert/sequences.py</code> <pre><code>def str_to_float(item: str, /) -&gt; float:\n    \"\"\"[summary]\n\n    Args:\n        item (str): [description]\n\n    Returns:\n        float: [description]\n    \"\"\"\n    \"\"\"Converts a str to a float.\"\"\"\n    return float(item)\n</code></pre>"},{"location":"reference/modify/convert/sequences/#modify.convert.sequences.str_to_list","title":"<code>str_to_list(item)</code>","text":"<p>[summary]</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>str</code> <p>[description]</p> required <p>Returns:</p> Type Description <code>list[Any]</code> <p>list[Any]: [description]</p> Source code in <code>src/modify/convert/sequences.py</code> <pre><code>def str_to_list(item: str, /) -&gt; list[Any]:\n    \"\"\"[summary]\n\n    Args:\n        item (str): [description]\n\n    Returns:\n        list[Any]: [description]\n    \"\"\"\n    \"\"\"Converts a str to a list.\"\"\"\n    return ast.literal_eval(item)\n</code></pre>"},{"location":"reference/modify/convert/sequences/#modify.convert.sequences.str_to_path","title":"<code>str_to_path(item)</code>","text":"<p>[summary]</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>str</code> <p>[description]</p> required <p>Returns:</p> Type Description <code>Path</code> <p>pathlib.Path: [description]</p> Source code in <code>src/modify/convert/sequences.py</code> <pre><code>@to_path.register\ndef str_to_path(item: str, /) -&gt; pathlib.Path:\n    \"\"\"[summary]\n\n    Args:\n        item (str): [description]\n\n    Returns:\n        pathlib.Path: [description]\n    \"\"\"\n    \"\"\"Converts a str to a pathlib.Path.\"\"\"\n    return pathlib.pathlib.Path(item)\n</code></pre>"},{"location":"reference/modify/convert/sequences/#modify.convert.sequences.to_float","title":"<code>to_float(item)</code>","text":"<p>Converts <code>item</code> to a float.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Any</code> <p>item to convert to a float.</p> required <p>Raises:</p> Type Description <code>TypeError</code> <p>if <code>item</code> is a type that is not registered.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>derived from <code>item</code>.</p> Source code in <code>src/modify/convert/sequences.py</code> <pre><code>def to_float(item: Any, /) -&gt; float:\n    \"\"\"Converts `item` to a float.\n\n    Args:\n        item (Any): item to convert to a float.\n\n    Raises:\n        TypeError: if `item` is a type that is not registered.\n\n    Returns:\n        float: derived from `item`.\n\n    \"\"\"\n    if isinstance(item, float):\n        return item\n    else:\n        raise TypeError(\n            f'item cannot be converted because it is an unsupported type: '\n            f'{type(item).__name__}')\n</code></pre>"},{"location":"reference/modify/convert/sequences/#modify.convert.sequences.to_list","title":"<code>to_list(item)</code>","text":"<p>Converts <code>item</code> to a list.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Any</code> <p>item to convert to a list.</p> required <p>Raises:</p> Type Description <code>TypeError</code> <p>if <code>item</code> is a type that is not registered.</p> <p>Returns:</p> Type Description <code>list[Any]</code> <p>list[Any]: derived from <code>item</code>.</p> Source code in <code>src/modify/convert/sequences.py</code> <pre><code>def to_list(item: Any, /) -&gt; list[Any]:\n    \"\"\"Converts `item` to a list.\n\n    Args:\n        item (Any): item to convert to a list.\n\n    Raises:\n        TypeError: if `item` is a type that is not registered.\n\n    Returns:\n        list[Any]: derived from `item`.\n\n    \"\"\"\n    if isinstance(item, list[Any]):\n        return item\n    else:\n        raise TypeError(\n            f'item cannot be converted because it is an unsupported type: '\n            f'{type(item).__name__}')\n</code></pre>"},{"location":"reference/modify/convert/sequences/#modify.convert.sequences.to_path","title":"<code>to_path(item)</code>","text":"<p>Converts <code>item</code> to a pathlib.Path.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Any</code> <p>item to convert to a pathlib.Path.</p> required <p>Raises:</p> Type Description <code>TypeError</code> <p>if <code>item</code> is a type that is not registered.</p> <p>Returns:</p> Type Description <code>Path</code> <p>pathlib.Path: derived from <code>item</code>.</p> Source code in <code>src/modify/convert/sequences.py</code> <pre><code>def to_path(item: Any, /) -&gt; pathlib.Path:\n    \"\"\"Converts `item` to a pathlib.Path.\n\n    Args:\n        item (Any): item to convert to a pathlib.Path.\n\n    Raises:\n        TypeError: if `item` is a type that is not registered.\n\n    Returns:\n        pathlib.Path: derived from `item`.\n\n    \"\"\"\n    if isinstance(item, pathlib.Path):\n        return item\n    else:\n        raise TypeError(\n            f'item cannot be converted because it is an unsupported type: '\n            f'{type(item).__name__}')\n</code></pre>"},{"location":"reference/modify/convert/sequences/#modify.convert.sequences.to_str","title":"<code>to_str(item)</code>","text":"<p>Converts <code>item</code> to a str.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Any</code> <p>item to convert to a str.</p> required <p>Raises:</p> Type Description <code>TypeError</code> <p>if <code>item</code> is a type that is not registered.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>derived from <code>item</code>.</p> Source code in <code>src/modify/convert/sequences.py</code> <pre><code>def to_str(item: Any, /) -&gt; str:\n    \"\"\"Converts `item` to a str.\n\n    Args:\n        item (Any): item to convert to a str.\n\n    Raises:\n        TypeError: if `item` is a type that is not registered.\n\n    Returns:\n        str: derived from `item`.\n\n    \"\"\"\n    if isinstance(item, str):\n        return item\n    else:\n        raise TypeError(\n            f'item cannot be converted because it is an unsupported type: '\n            f'{type(item).__name__}')\n</code></pre>"},{"location":"reference/modify/convert/sequences/#modify.convert.sequences.tuplify","title":"<code>tuplify(item, /, default=None)</code>","text":"<p>Returns passed item as a tuple (if not already a tuple).</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Any</code> <p>item to be transformed into a tuple.</p> required <code>default</code> <code>Any</code> <p>the default value to return if <code>item</code> is None. Unfortunately, to indicate you want None to be the default value, you need to put <code>None</code> in quotes. If not passed, <code>default</code> is set to ().</p> <code>None</code> <p>Returns:</p> Type Description <code>Any</code> <p>tuple[Any]: a passed tuple, <code>item</code> converted to a tuple, or <code>default</code>.</p> Source code in <code>src/modify/convert/sequences.py</code> <pre><code>@functools.singledispatch\ndef tuplify(item: Any, /, default: Any | None = None) -&gt; Any:\n    \"\"\"Returns passed item as a tuple (if not already a tuple).\n\n    Args:\n        item (Any): item to be transformed into a tuple.\n        default (Any): the default value to return if `item` is None.\n            Unfortunately, to indicate you want None to be the default value,\n            you need to put `None` in quotes. If not passed, `default`\n            is set to ().\n\n    Returns:\n        tuple[Any]: a passed tuple, `item` converted to a tuple, or\n            `default`.\n\n    \"\"\"\n    if item is None:\n        if default is None:\n            return ()\n        elif default in ['None', 'none']:\n            return None\n        else:\n            return default\n    elif isinstance(item, tuple):\n        return item\n    elif isinstance(item, Iterable):\n        return tuple(item)\n    else:\n        return (item,)\n</code></pre>"},{"location":"reference/modify/convert/strings/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> strings","text":"<p>Tools that convert to <code>str</code> types.</p> Contents <p>stringify: converts to or validates a str. int_to_str float_to_str list_to_str none_to_str path_to_str datetime_to_str</p> <p>To Do:</p>"},{"location":"reference/modify/convert/strings/#modify.convert.strings.datetime_to_string","title":"<code>datetime_to_string(item, /, time_format='%Y-%m-%d_%H-%M')</code>","text":"<p>Return datetime <code>item</code> as a str based on <code>time_format</code>.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>datetime</code> <p>datetime object to convert to a str.</p> required <code>time_format</code> <code>Optional[str]</code> <p>format to create a str from datetime. The passed argument should follow the rules of datetime.strftime. Defaults to '%Y-%m-%d_%H-%M'.</p> <code>'%Y-%m-%d_%H-%M'</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>converted datetime <code>item</code>.</p> Source code in <code>src/modify/convert/strings.py</code> <pre><code>def datetime_to_string(\n    item: datetime.datetime, /,\n    time_format: str | None = '%Y-%m-%d_%H-%M') -&gt; str:\n    \"\"\"Return datetime `item` as a str based on `time_format`.\n\n    Args:\n        item (datetime.datetime): datetime object to convert to a str.\n        time_format (Optional[str]): format to create a str from datetime. The\n            passed argument should follow the rules of datetime.strftime.\n            Defaults to '%Y-%m-%d_%H-%M'.\n\n    Returns:\n        str: converted datetime `item`.\n\n    \"\"\"\n    return item.strftime(time_format)\n</code></pre>"},{"location":"reference/modify/convert/strings/#modify.convert.strings.float_to_str","title":"<code>float_to_str(item)</code>","text":"<p>[summary]</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>float</code> <p>[description]</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>[description]</p> Source code in <code>src/modify/convert/strings.py</code> <pre><code>def float_to_str(item: float, /) -&gt; str:\n    \"\"\"[summary]\n\n    Args:\n        item (float): [description]\n\n    Returns:\n        str: [description]\n    \"\"\"\n    \"\"\"Converts an float to a str.\"\"\"\n    return str(item)\n</code></pre>"},{"location":"reference/modify/convert/strings/#modify.convert.strings.int_to_str","title":"<code>int_to_str(item)</code>","text":"<p>[summary]</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>int</code> <p>[description]</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>[description]</p> Source code in <code>src/modify/convert/strings.py</code> <pre><code>def int_to_str(item: int, /) -&gt; str:\n    \"\"\"[summary]\n\n    Args:\n        item (int): [description]\n\n    Returns:\n        str: [description]\n    \"\"\"\n    \"\"\"Converts an int to a str.\"\"\"\n    return str(item)\n</code></pre>"},{"location":"reference/modify/convert/strings/#modify.convert.strings.list_to_str","title":"<code>list_to_str(item)</code>","text":"<p>[summary]</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>list[Any]</code> <p>[description]</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>[description]</p> Source code in <code>src/modify/convert/strings.py</code> <pre><code>def list_to_str(item: list[Any], /) -&gt; str:\n    \"\"\"[summary]\n\n    Args:\n        item (list[Any]): [description]\n\n    Returns:\n        str: [description]\n    \"\"\"\n    \"\"\"Converts a list to a str.\"\"\"\n    return ', '.join(item)\n</code></pre>"},{"location":"reference/modify/convert/strings/#modify.convert.strings.none_to_str","title":"<code>none_to_str(item)</code>","text":"<p>[summary]</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>None</code> <p>[description]</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>[description]</p> Source code in <code>src/modify/convert/strings.py</code> <pre><code>def none_to_str(item: None, /) -&gt; str:\n    \"\"\"[summary]\n\n    Args:\n        item (None): [description]\n\n    Returns:\n        str: [description]\n    \"\"\"\n    \"\"\"Converts None to a str.\"\"\"\n    return 'None'\n</code></pre>"},{"location":"reference/modify/convert/strings/#modify.convert.strings.path_to_str","title":"<code>path_to_str(item)</code>","text":"<p>Converts a pathlib.Path to a str.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Path</code> <p>[description]</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>[description]</p> Source code in <code>src/modify/convert/strings.py</code> <pre><code>def path_to_str(item: pathlib.Path, /) -&gt; str:\n    \"\"\"Converts a pathlib.Path to a str.\n\n    Args:\n        item (pathlib.Path): [description]\n\n    Returns:\n        str: [description]\n\n    \"\"\"\n    return str(item)\n</code></pre>"},{"location":"reference/modify/convert/strings/#modify.convert.strings.stringify","title":"<code>stringify(item, /, default=None)</code>","text":"<p>Converts <code>item</code> to a str from a Sequence.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Any</code> <p>item to convert to a str from a list if it is a list.</p> required <code>default</code> <code>Any</code> <p>value to return if <code>item</code> is equivalent to a null value when passed. Defaults to None.</p> <code>None</code> <p>Raises:</p> Type Description <code>TypeError</code> <p>if <code>item</code> is not a str or list-like object.</p> <p>Returns:</p> Name Type Description <code>Any</code> <code>Any</code> <p>str, if item was a list, None or the default value if a null value was passed, or the item as it was passed if there previous two conditions don't appply.</p> Source code in <code>src/modify/convert/strings.py</code> <pre><code>@functools.singledispatch\ndef stringify(item: Any, /, default: Any | None = None) -&gt; Any:\n    \"\"\"Converts `item` to a str from a Sequence.\n\n    Args:\n        item (Any): item to convert to a str from a list if it is a list.\n        default (Any): value to return if `item` is equivalent to a null\n            value when passed. Defaults to None.\n\n    Raises:\n        TypeError: if `item` is not a str or list-like object.\n\n    Returns:\n        Any: str, if item was a list, None or the default value if a null value\n            was passed, or the item as it was passed if there previous two\n            conditions don't appply.\n\n    \"\"\"\n    if item is None:\n        if default is None:\n            return ''\n        elif default in ['None', 'none']:\n            return None\n        else:\n            return default\n    elif isinstance(item, str):\n        return item\n    elif isinstance(item, Sequence):\n        return ', '.join(item)\n    else:\n        raise TypeError('item must be str or a sequence')\n</code></pre>"},{"location":"reference/modify/convert/strings/#modify.convert.strings.to_str","title":"<code>to_str(item)</code>","text":"<p>Converts <code>item</code> to a str.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Any</code> <p>item to convert to a str.</p> required <p>Raises:</p> Type Description <code>TypeError</code> <p>if <code>item</code> is a type that is not registered.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>derived from <code>item</code>.</p> Source code in <code>src/modify/convert/strings.py</code> <pre><code>def to_str(item: Any, /) -&gt; str:\n    \"\"\"Converts `item` to a str.\n\n    Args:\n        item (Any): item to convert to a str.\n\n    Raises:\n        TypeError: if `item` is a type that is not registered.\n\n    Returns:\n        str: derived from `item`.\n\n    \"\"\"\n    if isinstance(item, str):\n        return item\n    else:\n        raise TypeError(\n            f'item cannot be converted because it is an unsupported type: '\n            f'{type(item).__name__}')\n</code></pre>"},{"location":"reference/modify/convert/strings/#modify.convert.strings.tuplify","title":"<code>tuplify(item, /, default=None)</code>","text":"<p>Returns passed item as a tuple (if not already a tuple).</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Any</code> <p>item to be transformed into a tuple.</p> required <code>default</code> <code>Any</code> <p>the default value to return if <code>item</code> is None. Unfortunately, to indicate you want None to be the default value, you need to put <code>None</code> in quotes. If not passed, <code>default</code> is set to ().</p> <code>None</code> <p>Returns:</p> Type Description <code>Any</code> <p>tuple[Any]: a passed tuple, <code>item</code> converted to a tuple, or <code>default</code>.</p> Source code in <code>src/modify/convert/strings.py</code> <pre><code>@functools.singledispatch\ndef tuplify(item: Any, /, default: Any | None = None) -&gt; Any:\n    \"\"\"Returns passed item as a tuple (if not already a tuple).\n\n    Args:\n        item (Any): item to be transformed into a tuple.\n        default (Any): the default value to return if `item` is None.\n            Unfortunately, to indicate you want None to be the default value,\n            you need to put `None` in quotes. If not passed, `default`\n            is set to ().\n\n    Returns:\n        tuple[Any]: a passed tuple, `item` converted to a tuple, or\n            `default`.\n\n    \"\"\"\n    if item is None:\n        if default is None:\n            return ()\n        elif default in ['None', 'none']:\n            return None\n        else:\n            return default\n    elif isinstance(item, tuple):\n        return item\n    elif isinstance(item, Iterable):\n        return tuple(item)\n    else:\n        return (item,)\n</code></pre>"}]}